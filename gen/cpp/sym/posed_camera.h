// -----------------------------------------------------------------------------
// This file was autogenerated by symforce from template:
//     cam_package/posed_camera.h.jinja
// Do NOT modify by hand.
// -----------------------------------------------------------------------------

#pragma once

#include <Eigen/Dense>

#include <sym/camera.h>
#include <sym/pose3.h>

namespace sym {

/**
 * Camera with a given pose, camera calibration, and an optionally specified image size.
 * If the image size is specified, we use it to check whether pixels (either given or computed by
 * projection of 3D points into the image frame) are in the image frame and thus valid/invalid.
 */
template <typename CameraCalType>
class PosedCamera : public Camera<CameraCalType> {
 public:
  using Scalar = typename CameraCalType::Scalar;

  PosedCamera(const sym::Pose3<Scalar>& pose, const CameraCalType& calibration,
              const Eigen::Vector2i& image_size = Eigen::Vector2i(-1, -1))
      : Camera<CameraCalType>(calibration, image_size), pose_(pose) {}

  /**
   * Transforms the given point into the camera frame using the given camera pose and then
   * uses the given camera calibration to compute the resulted pixel coordinates of the
   * projected point.
   *
   * Args:
   *     point: Vector written in camera frame.
   *     epsilon: Small value intended to prevent division by 0.
   *
   * Return:
   *     pixel: UV coodinates in pixel units, assuming the point is in view
   *     is_valid: 1 if point is valid
   *
   */
  Eigen::Matrix<Scalar, 2, 1> PixelFromGlobalPoint(const Eigen::Matrix<Scalar, 3, 1>& point,
                                                   const Scalar epsilon,
                                                   Scalar* const is_valid) const {
    const Eigen::Matrix<Scalar, 3, 1> camera_point = pose_.InverseCompose(point);
    const Eigen::Matrix<Scalar, 2, 1> pixel =
        Camera<CameraCalType>::PixelFromCameraPoint(camera_point, epsilon, is_valid);
    return pixel;
  }

  /**
   * Computes a point written in the global frame along the ray passing through the center
   * of the given pixel. The point is positioned at a given range along the ray.
   *
   * Args:
   *     pixel: Vector in pixels in camera image.
   *     range_to_point: Distance of the returned point along the ray passing through pixel
   *     epsilon: Small value intended to prevent division by 0.
   *
   * Return:
   *     global_point: The point in the global frame.
   *     is_valid: 1 if point is valid
   *
   */
  Eigen::Matrix<Scalar, 3, 1> GlobalPointFromPixel(const Eigen::Matrix<Scalar, 2, 1>& pixel,
                                                   Scalar range_to_point, const Scalar epsilon,
                                                   Scalar* const is_valid) const {
    const Eigen::Matrix<Scalar, 3, 1> camera_ray =
        Camera<CameraCalType>::CameraRayFromPixel(pixel, epsilon, is_valid);
    const Eigen::Matrix<Scalar, 3, 1> camera_point = range_to_point * camera_ray.normalized();
    const Eigen::Matrix<Scalar, 3, 1> global_point = pose_ * camera_point;
    return global_point;
  }

  /**
   * Project a pixel in this camera into another camera.
   *
   * Args:
   *     pixel: Pixel in the source camera
   *     inverse_range: Inverse distance along the ray to the global point
   *     target_cam: Camera to project global point into
   *
   * Return:
   *     pixel: Pixel in the target camera
   *     is_valid: 1 if given point is valid in source camera and target camera
   *
   */
  Eigen::Matrix<Scalar, 2, 1> WarpPixel(const Eigen::Matrix<Scalar, 2, 1>& pixel,
                                        Scalar inverse_range, const PosedCamera& target_cam,
                                        const Scalar epsilon, Scalar* const is_valid) const {
    // See warp_pixel() in posed_camera.py.
    Scalar is_valid_ray;
    const Eigen::Matrix<Scalar, 3, 1> camera_ray =
        Camera<CameraCalType>::CameraRayFromPixel(pixel, epsilon, &is_valid_ray);
    const Eigen::Matrix<Scalar, 3, 1> camera_point = camera_ray.normalized();

    const sym::Pose3<Scalar>& target_T_self = target_cam.Pose().Inverse() * Pose();
    const Eigen::Matrix<Scalar, 3, 1> transformed_point =
        target_T_self.Rotation() * camera_point + (target_T_self.Position() * inverse_range);

    Scalar is_valid_projection;
    const Eigen::Matrix<Scalar, 2, 1> target_pixel =
        target_cam.PixelFromCameraPoint(transformed_point, epsilon, &is_valid_projection);

    *is_valid = is_valid_ray * is_valid_projection;
    return target_pixel;
  }

  const sym::Pose3<Scalar>& Pose() const {
    return pose_;
  }

 private:
  sym::Pose3<Scalar> pose_;
};

}  // namespace sym
