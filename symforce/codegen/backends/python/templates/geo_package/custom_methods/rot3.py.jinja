{# ----------------------------------------------------------------------------
 # SymForce - Copyright 2022, Skydio, Inc.
 # This source code is under the Apache 2.0 license found in the LICENSE file.
 # ---------------------------------------------------------------------------- #}
{%- import "../../util/util.jinja" as util with context -%}

    {# Handwritten methods for Rot3 #}
    {# These will get included into the autogenerated class header. #}
    def __init__(self, q: T.Union[T.Sequence[float], numpy.ndarray, None] = None) -> None:
        if q is None:
            self.data: list[float] = ops.GroupOps.identity().data
        else:
            {{ util.flatten_if_ndarray("q", 4) | indent(width=12) }}
            self.data = list(q)

    @classmethod
    def from_rotation_matrix(cls, R: numpy.ndarray, epsilon: float = 0.0) -> Rot3:
        """
        This implementation is based on Shepperd's method (1978)
        https://arc.aiaa.org/doi/abs/10.2514/3.55767b?journalCode=jgc (this is paywalled)

        See the introduction of these papers for a description of the method:
        - https://digital.csic.es/bitstream/10261/179990/1/Accurate%20Computation_Sarabandi.pdf
        - https://arc.aiaa.org/doi/abs/10.2514/1.31730?journalCode=jgcd
        """
        {# TODO(aaron, ryan): codegen this #}
        assert R.shape == (3, 3)
        trace = R[0, 0] + R[1, 1] + R[2, 2]
        # trace is larger than any of the diagonal elements
        if trace > R[0, 0] and trace > R[1, 1] and trace > R[2, 2]:
            w = numpy.sqrt(1.0 + trace) / 2.0
            x = (R[2, 1] - R[1, 2]) / (4.0 * w)
            y = (R[0, 2] - R[2, 0]) / (4.0 * w)
            z = (R[1, 0] - R[0, 1]) / (4.0 * w)
        # largest diagonal element is R[0,0]
        elif R[0, 0] > R[1, 1] and R[0, 0] > R[2, 2]:
            x = numpy.sqrt(max(epsilon**2, 1.0 + R[0, 0] - R[1, 1] - R[2, 2])) / 2.0
            y = (R[0, 1] + R[1, 0]) / (4.0 * x)
            z = (R[0, 2] + R[2, 0]) / (4.0 * x)
            w = (R[2, 1] - R[1, 2]) / (4.0 * x)
        # largest diagonal element is R[1,1]
        elif R[1, 1] > R[2, 2]:
            y = numpy.sqrt(max(epsilon**2, 1.0 + R[1, 1] - R[0, 0] - R[2, 2])) / 2.0
            x = (R[0, 1] + R[1, 0]) / (4.0 * y)
            z = (R[1, 2] + R[2, 1]) / (4.0 * y)
            w = (R[0, 2] - R[2, 0]) / (4.0 * y)
        # largest diagonal element is R[2,2]
        else:
            z = numpy.sqrt(max(epsilon**2, 1.0 + R[2, 2] - R[0, 0] - R[1, 1])) / 2.0
            x = (R[0, 2] + R[2, 0]) / (4.0 * z)
            y = (R[1, 2] + R[2, 1]) / (4.0 * z)
            w = (R[1, 0] - R[0, 1]) / (4.0 * z)

        return Rot3.from_storage([x, y, z, w])

    @classmethod
    def random(cls) -> Rot3:
        return Rot3.random_from_uniform_samples(
            random.uniform(0, 1), random.uniform(0, 1), random.uniform(0, 1)
        )
