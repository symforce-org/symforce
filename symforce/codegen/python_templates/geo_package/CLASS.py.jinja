# -----------------------------------------------------------------------------
# This file was autogenerated by symforce. Do NOT modify by hand.
# -----------------------------------------------------------------------------
import numpy as np
import typing as T

{# If a pose type, include the necessary rotation type. #}
{% if cls.__name__.startswith('Pose') %}
from .rot{{ cls.__name__[-1] }} import Rot{{ cls.__name__[-1] }}
{% endif -%}

from .ops import {{ camelcase_to_snakecase(cls.__name__) }} as ops


class {{ cls.__name__ }}(object):
    {% if doc %}
    """"
    Autogenerated Python implementation of {{ cls }}.

    {% for line in doc.split('\n') %}
{{ '    {}'.format(line).rstrip() }}
    {% endfor %}
    """
    {% endif %}

    __slots__ = ['data']

    def __repr__(self):
        # type: () -> str
        return '<{} {}>'.format(self.__class__.__name__, self.data)

    {% set custom_template_name = "custom_methods/{}.py.jinja".format(cls.__name__.lower()) %}
    # --------------------------------------------------------------------------
    # Handwritten methods included from "{{ custom_template_name }}"
    # --------------------------------------------------------------------------
    
    {% include custom_template_name %}

    # --------------------------------------------------------------------------
    # StorageOps concept
    # --------------------------------------------------------------------------

    @staticmethod
    def storage_dim():
        # type: () -> int
        return {{ ops.StorageOps.storage_dim(cls) }}

    def to_storage(self):
        # type: () -> T.List[float]
        return list(self.data)

    @classmethod
    def from_storage(cls, vec):
        # type: (T.Sequence[float]) -> {{ cls.__name__ }}
        instance = cls()

        if isinstance(vec, list):
            instance.data = vec
        else:
            instance.data = list(vec)

        assert len(vec) == cls.storage_dim(), '{} has storage dim {}, got {}.'.format(
            cls.__name__, cls.storage_dim(), len(vec))

        return instance

    # --------------------------------------------------------------------------
    # GroupOps concept
    # --------------------------------------------------------------------------

    @classmethod
    def identity(cls):
        # type: () -> {{ cls.__name__ }}
        return cls.from_storage(ops.GroupOps.identity())

    def inverse(self):
    # type: () -> {{ cls.__name__ }}
        return self.__class__.from_storage(ops.GroupOps.inverse(self))

    def compose(self, b):
        # type: ({{ cls.__name__ }}) -> {{ cls.__name__ }}
        return self.__class__.from_storage(ops.GroupOps.compose(self, b))

    def between(self, b):
        # type: ({{ cls.__name__ }}) -> {{ cls.__name__ }}
        return self.__class__.from_storage(ops.GroupOps.between(self, b))

    {% if is_lie_group %}
    # --------------------------------------------------------------------------
    # LieGroupOps concept
    # --------------------------------------------------------------------------

    @staticmethod
    def tangent_dim():
        # type: () -> int
        return {{ ops.LieGroupOps.tangent_dim(cls) }}

    @classmethod
    def from_tangent(cls, vec, epsilon=1e-8):
        # type: (T.Sequence[float], float) -> {{ cls.__name__ }}
        assert len(vec) == cls.tangent_dim(), '{}, {}'.format(len(vec), cls.tangent_dim())
        return cls.from_storage(ops.LieGroupOps.from_tangent(vec, epsilon))

    def to_tangent(self, epsilon=1e-8):
        # type: (float) -> T.List[float]
        return ops.LieGroupOps.to_tangent(self, epsilon)

    def retract(self, vec, epsilon=1e-8):
        # type: (T.Sequence[float], float) -> {{ cls.__name__ }}
        assert len(vec) == self.tangent_dim(), '{}, {}'.format(len(vec), self.tangent_dim())
        return self.__class__.from_storage(ops.LieGroupOps.retract(self, vec, epsilon))

    def local_coordinates(self, b, epsilon=1e-8):
        # type: ({{ cls.__name__ }}, float) -> T.List[float]
        return ops.LieGroupOps.local_coordinates(self, b, epsilon)
    {% endif %}

    # --------------------------------------------------------------------------
    # General Helpers
    # --------------------------------------------------------------------------
    def __eq__(self, other):
        # type: (T.Any) -> bool
        if isinstance(other, {{ cls.__name__ }}):
            return self.data == other.data
        else:
            raise NotImplementedError('Cannot compare {} to {}'.format(type(self), type(other)))

    @T.overload
    def __mul__(self, other):  # pragma: no cover
        # type: ({{ cls.__name__ }}) -> {{ cls.__name__ }}
        pass

    @T.overload
    def __mul__(self, other):  # pragma: no cover
        # type: (np.ndarray) -> np.ndarray
        pass

    def __mul__(self, other):
        # type: (T.Union[{{ cls.__name__ }}, np.ndarray]) -> T.Union[{{ cls.__name__ }}, np.ndarray]
        if isinstance(other, {{ cls.__name__ }}):
            return self.compose(other)
        elif isinstance(other, np.ndarray) and hasattr(self, "_apply_to_vector"):
            return self._apply_to_vector(other)
        else:
            raise NotImplementedError('Cannot compose {} with {}.'.format(type(self), type(other)))
