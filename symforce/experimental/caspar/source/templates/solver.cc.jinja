{# ----------------------------------------------------------------------------
 # SymForce - Copyright 2025, Skydio, Inc.
 # This source code is under the Apache 2.0 license found in the LICENSE file.
 # ---------------------------------------------------------------------------- #}
#include "solver.h"

#include <stdexcept>
#include <algorithm>
#include <chrono>

#include "caspar_mappings.h"
#include "shared_indices.h"
#include "solver_tools.h"
#include "sort_indices.h"

{% for fac in solver.factors%}
#include "kernel_{{fac.name}}_res_jac.h"
#include "kernel_{{fac.name}}_res_jac_first.h"
#include "kernel_{{fac.name}}_jtjnjtr_direct.h"
#include "kernel_{{fac.name}}_score.h"
{% endfor %}
{% for nodetype in solver.node_types%}
#include "kernel_{{nodetype.__name__}}_alpha_denumerator_or_beta_nummerator.h"
#include "kernel_{{nodetype.__name__}}_alpha_numerator_denominator.h"
#include "kernel_{{nodetype.__name__}}_normalize.h"
#include "kernel_{{nodetype.__name__}}_pred_decrease_times_two.h"
#include "kernel_{{nodetype.__name__}}_retract.h"
#include "kernel_{{nodetype.__name__}}_start_w.h"
#include "kernel_{{nodetype.__name__}}_start_w_contribute.h"
#include "kernel_{{nodetype.__name__}}_update_r.h"
#include "kernel_{{nodetype.__name__}}_update_r_first.h"
#include "kernel_{{nodetype.__name__}}_update_step_first.h"
#include "kernel_{{nodetype.__name__}}_update_step.h"
#include "kernel_{{nodetype.__name__}}_update_p.h"
#include "kernel_{{nodetype.__name__}}_update_Mp.h"
{% if nodetype in solver.tridig_Uk_syms %}
#include "kernel_{{nodetype.__name__}}_tridig_make_eq.h"
#include "kernel_{{nodetype.__name__}}_solve_two.h"
#include "kernel_{{nodetype.__name__}}_CR_down.h"
#include "kernel_{{nodetype.__name__}}_CR_up.h"
{% endif %}
{% endfor %}

namespace {

void make_aligned(size_t& offset, size_t alignment_bytes) {
  offset = ((offset + alignment_bytes - 1) / alignment_bytes) * alignment_bytes;
}

template <typename T>
void increment_offset(size_t& offset, size_t num_elements, size_t alignment_elements) {
  make_aligned(offset, alignment_elements*sizeof(T));
  offset += num_elements * sizeof(T);
}

template <typename T>
T* assign_and_increment(uint8_t* origin_ptr, size_t& offset, size_t num_elements, size_t alignment_elements) {
  make_aligned(offset, alignment_elements*sizeof(T));
  size_t old_offset = offset;
  offset += num_elements * sizeof(T);
  return reinterpret_cast<T*>(origin_ptr + old_offset);
}

}  // namespace

namespace caspar {

{{ solver.struct_name }}::{{ solver.struct_name }}(
    const SolverParams<double> &params,
    {% for thing in solver.size_contributors %}
    size_t {{num_arg_key(thing)}}{{ ", " if not loop.last else "" }}
    {% endfor %}
    )
    : params_(params),
      {% for thing in solver.size_contributors %}
      {{num_key(thing)}}({{num_arg_key(thing)}}),
      {{num_max_key(thing)}}({{num_arg_key(thing)}}){{ ", " if not loop.last else "" }}
      {% endfor %}
      {
  indices_valid_ = false;
  if (params.pcg_rel_error_exit<= 0.0f){
    throw std::runtime_error("params.pcg_rel_error_exit must be positive");
  }
  if (params.diag_init < 0.0f){
    throw std::runtime_error("params.diag_init must be positive");
  }
  allocation_size_ = get_nbytes();
  cudaMalloc(&origin_ptr_, allocation_size_);

  size_t offset = 0;
  {% for name, field in solver.fields.items() %}
  {{name}} = assign_and_increment<{{field.dtype}}>(
      origin_ptr_, offset, {{field.dim_real}} * {{field.num_key}}, {{field.alignment}});
  {% endfor %}

  scratch_inout_size_ = offset;  // sorting, sum,
}

{{ solver.struct_name }}::~{{ solver.struct_name }}(){
  cudaFree(origin_ptr_);
}

void {{ solver.struct_name }}::set_params(const SolverParams<double> &params){
  this->params_ = params;
}

size_t {{ solver.struct_name }}::get_allocation_size(){
  return allocation_size_;
}


{{solver.linear_t}} {{ solver.struct_name }}::solve(bool print_progress) {
  {{solver.linear_t}} score_best;
  {{solver.linear_t}} score_best_pcg;
  {{solver.linear_t}} diag = params_.diag_init;
  cudaMemcpy({{solver_key("current_diag")}}, &diag, sizeof({{solver.linear_t}}), cudaMemcpyHostToDevice);

  {{solver.linear_t}} up_scale = params_.diag_scaling_up;
  {{solver.linear_t}} quality;

  std::chrono::time_point<std::chrono::steady_clock> t0 = std::chrono::steady_clock::now();
  std::chrono::time_point<std::chrono::steady_clock> t_prev = t0;
  score_best = do_res_jac_first();
  if (print_progress) {
    printf("                                 score_init: % .6e\n", score_best);
  }

  for (solver_iter_ = 0; solver_iter_ < params_.solver_iter_max; solver_iter_++) {
    if (solver_iter_ != 0 && solver_iter_ < params_.solver_iter_max - 1){
      do_res_jac();
    }
    score_best_pcg = score_best;
    for (pcg_iter_ = 0; pcg_iter_ < params_.pcg_iter_max; pcg_iter_++){
      do_normalize();

      if (pcg_iter_ == 0) {
        copy(marker__r_k_start_, marker__r_k_end_, marker__w_start_);
        do_jtjp_direct();
        do_alpha_first();
        do_update_step_first();
        do_update_r_first();
      } else {
        do_beta();
        do_update_p();
        do_update_Mp();
        do_jtjp_direct();
        do_alpha();
        do_update_step();
        do_update_r();
      }
      if (params_.pcg_rel_decrease_min != -1.0f || params_.pcg_rel_score_exit != -1.0f) {
        {{solver.linear_t}} score_new_pcg = do_retract_score();
        if (!(score_new_pcg <= score_best_pcg * params_.pcg_rel_decrease_min)) {
          break;
        }
        {% for node_type in solver.node_types %}
        std::swap({{node_key(node_type, "storage_check")}},
                  {{node_key(node_type, "storage_new_best")}});
        {% endfor %}
        score_best_pcg = score_new_pcg;
        if (params_.pcg_rel_score_exit != -1.0f
            &&score_best_pcg < score_best * params_.pcg_rel_score_exit){
          break;
        }
      }
      if (pcg_r_kp1_norm2_ < pcg_r_0_norm2_ * params_.pcg_rel_error_exit){
        break;
      }
    }
    pcg_iter_ = std::min(pcg_iter_, params_.pcg_iter_max-1);

    if (params_.pcg_rel_decrease_min == -1.0f && params_.pcg_rel_score_exit == -1.0f) {
      score_best_pcg = do_retract_score();
      {% for node_type in solver.node_types %}
      std::swap({{node_key(node_type, "storage_check")}},
                {{node_key(node_type, "storage_new_best")}});
      {% endfor %}
    }

    if (score_best_pcg < score_best * params_.solver_rel_decrease_min) {
      quality = (score_best - score_best_pcg) / get_pred_decrease();
      const {{solver.linear_t}} quality_tmp = 2 * quality - 1;
      {{solver.linear_t}} scale =
          std::max(params_.diag_scaling_down, 1.0f - quality_tmp * quality_tmp * quality_tmp);
      diag = std::max(params_.diag_min, diag * scale);
      cudaMemcpy({{solver_key("current_diag")}}, &diag, sizeof({{solver.linear_t}}), cudaMemcpyHostToDevice);
      up_scale = params_.diag_scaling_up;
      score_best = score_best_pcg;
      {% for node_type in solver.node_types %}
      std::swap({{node_key(node_type, "storage_current")}},
                {{node_key(node_type, "storage_new_best")}});
      {% endfor %}

    } else {
      quality = 0.0f;
      diag = diag * up_scale;
      if (diag > params_.diag_exit_value) {
        break;
      }
      cudaMemcpy({{solver_key("current_diag")}}, &diag, sizeof({{solver.linear_t}}), cudaMemcpyHostToDevice);
      up_scale *= 2;
    }
    const auto t_now = std::chrono::steady_clock::now();
    if (print_progress) {
      printf("solver_iter: % 3d  ", solver_iter_);
      printf("pcg_iter: % 3d  ", pcg_iter_);
      printf("score_current: % 13.6e  ", score_best_pcg);
      printf("score_best: % 13.6e  ", score_best);
      printf("step_quality: % 7.3f  ", quality);
      printf("diag: % 6.3e  ", diag);
      printf("dt_inc: % 10.6f  ", (float)(t_now - t_prev).count() * 1e-9);
      printf("dt_tot: % 10.6f  ", (float)(t_now - t0).count() * 1e-9);
      t_prev = t_now;
      printf("\n");
    }
    if (score_best <= params_.score_exit_value) {
      break;
    }
  }

  return score_best;
}


{%for isfirst in ["_first", ""]%}
  {% if isfirst == "_first" %} {{solver.linear_t}} {% else %} void {% endif %} {{ solver.struct_name }}::do_res_jac{{isfirst}}() {
    zero({{solver_key("res_tot")}}, {{solver_key("res_tot")}}+1);
    zero(marker__r_0_start_, marker__precond_end_);

    {% for fac in solver.factors %}

    {{fac.name}}_res_jac{{isfirst}}(
        {% for arg, typ in fac.arg_types.items() %}
          {% if fac.isnode[arg] %}
            {% if fac.isnodepair[arg] %}
                {{node_key(typ, "storage_current")}},
                {{num_max_key(typ)}},
            {% elif fac.isnodeuniq[arg] %}
                {{node_key(typ, "storage_current")}},
            {% elif fac.isnodeshared[arg] %}
                {{node_key(typ, "storage_current")}},
                {{num_max_key(typ)}},
                {{arg_key(fac, arg, "idx_shared")}},
            {% endif %}
          {% else %}
            {% if fac.isconstseq[arg] %}
                {{arg_key(fac, arg, "data")}},
                {{num_max_key(fac)}},
            {% elif fac.isconstshared[arg] %}
                {{arg_key(fac, arg, "data")}}, {{num_max_key(fac)}}, {{arg_key(fac, arg, "idx_shared")}},
            {% elif fac.isconstindexed[arg] %}
                {{arg_key(fac, arg, "data")}}, {{num_max_key(fac)}}, {{arg_key(fac, arg, "idx")}},
            {% elif fac.isconstuniq[arg] %}
                {{arg_key(fac, arg, "data")}},
            {% endif %}
          {% endif %}
        {% endfor %}

        {{fac_key(fac, "res")}},{{num_key(fac)}},
        {% if isfirst == "_first" %}{{solver_key("res_tot")}},{% endif %}

        {% for arg, typ in fac.node_arg_types.items()%}
        {% if fac.isnodepair[arg] %}
            {% if not fac.solved_by_preconditioner %}
            {{arg_key(fac, arg, "jac_first")}}, {{num_key(fac)}},
            {{arg_key(fac, arg, "jac_second")}}, {{num_key(fac)}},
            {% endif %}
            {{node_key(typ, "tridig_U")}}, {{num_key(typ)}}-1,
            {{node_key(typ, "r_k")}}, {{num_key(typ)}},
            {{node_key(typ, "precond_diag")}}, {{num_key(typ)}},
            {{node_key(typ, "precond_tril")}}, {{num_key(typ)}},
        {% elif fac.isnodeuniq[arg] %}
            {% if not fac.solved_by_preconditioner %}
            {{arg_key(fac, arg, "jac")}},{{num_key(fac)}},
            {% endif %}
            {{node_key(typ, "r_k")}},
            {{node_key(typ, "precond_diag")}},
            {{node_key(typ, "precond_tril")}},
        {% else %}
            {% if not fac.solved_by_preconditioner %}
            {{arg_key(fac, arg, "jac")}},{{num_key(fac)}},
            {% endif %}
            {{node_key(typ, "r_k")}}, {{num_key(typ)}},
            {{node_key(typ, "precond_diag")}}, {{num_key(typ)}},
            {{node_key(typ, "precond_tril")}}, {{num_key(typ)}},
        {% endif %}
        {% endfor %}
        {{num_key(fac)}}
    );
    {% endfor %}
    copy(marker__r_k_start_, marker__r_k_end_, marker__r_0_start_);
    copy(marker__r_k_start_, marker__r_k_end_, marker__Mp_start_);
    {% if isfirst == "_first" %}
    return 0.5 * read_cumem({{solver_key("res_tot")}});
    {% endif %}
  }
{%endfor%}

void {{ solver.struct_name }}::do_normalize() {
    {{solver.linear_t}}* r_k;
    {{solver.linear_t}}* z;
    {% for nodetype in solver.node_types%}
    z = pcg_iter_ == 0 ? {{node_key(nodetype, "p")}} : {{node_key(nodetype, "z")}};
    {% if nodetype not in solver.tridig_Uk_syms %}
    {{nodetype.__name__}}_normalize(
        {{node_key(nodetype, "precond_diag")}}, {{num_key(nodetype)}},
        {{node_key(nodetype, "precond_tril")}}, {{num_key(nodetype)}},
        {{node_key(nodetype, "r_k")}}, {{num_key(nodetype)}},
        {{solver_key("current_diag")}},
        z, {{num_key(nodetype)}},
        {{num_key(nodetype)}}
    );
    {% else %}
      zero(z, pcg_iter_ == 0 ? {{node_key(nodetype, "p_end_")}} : {{node_key(nodetype, "z_end_")}});
      {{nodetype.__name__}}_tridig_make_eq(
        {{node_key(nodetype, "precond_diag")}}, {{num_key(nodetype)}},
        {{node_key(nodetype, "precond_tril")}}, {{num_key(nodetype)}},
        {{node_key(nodetype, "tridig_U")}}, {{num_key(nodetype)}}-1 , -1,  1,
        {{node_key(nodetype, "r_k")}}, {{num_key(nodetype)}},
        {{solver_key("current_diag")}},
        {{node_key(nodetype, "tridig_eq")}}, {{num_key(nodetype)}},
        {{num_key(nodetype)}}
      );
      int i;
      int offset= 0;
      int remaining = {{num_key(nodetype)}};
      for (i=0; 2<<i < {{num_key(nodetype)}}; i++) {


          offset += (~remaining&1)<<i;
          remaining = (remaining+1)>>1;

        {{nodetype.__name__}}_CR_down(
          {{node_key(nodetype, "tridig_eq")}}, {{num_key(nodetype)}}, offset, (2<<i),
          {{node_key(nodetype, "tridig_eq")}}, {{num_key(nodetype)}}, offset - (1<<i), (2<<i),
          {{node_key(nodetype, "tridig_eq")}}, {{num_key(nodetype)}}, offset, (2<<i),
          remaining
        );
      }
      i--;

      {{nodetype.__name__}}_solve_two(
        {{node_key(nodetype, "tridig_eq")}}, {{num_key(nodetype)}}, offset, (2<<i),
        z, {{num_key(nodetype)}}, offset, 1,
        z, {{num_key(nodetype)}}, offset+(2<<i), 1,
        1
      );

      for (; i>=0; i--){
          int is_odd = offset < 1<<i;
          int shift = (is_odd*2 - 1)*(1<<i);

        {{nodetype.__name__}}_CR_up(
          {{node_key(nodetype, "tridig_eq")}}, {{num_key(nodetype)}}, offset+ shift, (2<<i),
          z, {{num_key(nodetype)}}, offset+shift-(1<<i) , (2<<i),
          z, {{num_key(nodetype)}}, offset+shift, (2<<i),
          remaining - is_odd
        );
        offset += shift* (!is_odd);
        remaining = remaining*2-is_odd;
      }
    {% endif %}
    {% endfor%}
}

void {{ solver.struct_name }}::do_update_Mp() {
    {% for nodetype in solver.node_types %}
    {{nodetype.__name__}}_update_Mp(
        {{node_key(nodetype, "r_k")}}, {{num_key(nodetype)}},
        {{node_key(nodetype, "Mp")}}, {{num_key(nodetype)}},
        {{solver_key("beta")}},
        {{node_key(nodetype, "Mp")}}, {{num_key(nodetype)}},
        {{node_key(nodetype, "w")}}, {{num_key(nodetype)}},
        {{num_key(nodetype)}}
    );
    {% endfor %}
}

void {{ solver.struct_name }}::do_jtjp_direct() {
    {% for fac in solver.factors %}
    {% if not fac.solved_by_preconditioner %}
      {{fac.name}}_jtjnjtr_direct(
      {% for arg, nodetype in fac.node_arg_types.items() %}
        {% if fac.isnodepair[arg] %}
            {{node_key(nodetype, "p")}},
            {{num_key(nodetype)}},
            {{arg_key(fac, arg, "jac_first")}}, {{num_key(fac)}},
            {{arg_key(fac, arg, "jac_second")}}, {{num_key(fac)}},
        {% elif fac.isnodeuniq[arg] %}
            {{node_key(nodetype, "p")}},
            {{arg_key(fac, arg, "jac")}}, {{num_key(fac)}},
        {% elif fac.isnodeshared[arg] %}
            {{node_key(nodetype, "p")}},
            {{num_key(nodetype)}},
            {{arg_key(fac, arg, "idx_shared")}},
            {{arg_key(fac, arg, "jac")}}, {{num_key(fac)}},
        {% endif %}
      {% endfor %}
      {% for arg, nodetype in fac.node_arg_types.items()%}
      {% if fac.isnodepair[arg] %}
          {{node_key(nodetype, "w")}}, {{num_key(nodetype)}},
      {% elif fac.isnodeuniq[arg] %}
          {{node_key(nodetype, "w")}},
      {% else %}
          {{node_key(nodetype, "w")}}, {{num_key(nodetype)}},
      {% endif %}
      {% endfor %}
      {{num_key(fac)}}
  );
  {% endif %}
  {% endfor %}
}

void {{ solver.struct_name }}::do_alpha_first() {
    zero({{solver_key("alpha_numerator")}}, {{solver_key("alpha_denumerator")}}+1);
    {{solver.linear_t}}* p_kp1;
    {{solver.linear_t}}* r_k;
    {% for nodetype in solver.node_types %}
    {{nodetype.__name__}}_alpha_numerator_denominator(
        {{node_key(nodetype, "p")}}, {{num_key(nodetype)}},
        {{node_key(nodetype, "r_k")}}, {{num_key(nodetype)}},
        {{node_key(nodetype, "w")}}, {{num_key(nodetype)}},
        {{solver_key( "alpha_numerator")}},
        {{solver_key( "alpha_denumerator")}},
        {{num_key(nodetype)}}
    );
    {% endfor %}

    alpha_from_num_denum({{solver_key("alpha_numerator")}}, {{solver_key("alpha_denumerator")}}, {{solver_key("alpha")}},
                         {{solver_key("neg_alpha")}});
}

void {{ solver.struct_name }}::do_alpha() {
    zero({{solver_key("alpha_denumerator")}}, {{solver_key("alpha_denumerator")}}+1);
    {% for nodetype in solver.node_types %}
    {{nodetype.__name__}}_alpha_denumerator_or_beta_nummerator(
        {{node_key(nodetype, "p")}}, {{num_key(nodetype)}},
        {{node_key(nodetype, "w")}}, {{num_key(nodetype)}},
        {{solver_key("alpha_denumerator")}},
        {{num_key(nodetype)}}
    );
    {% endfor %}


    alpha_from_num_denum({{solver_key("beta_numerator")}}, {{solver_key("alpha_denumerator")}}, {{solver_key("alpha")}},
                         {{solver_key("neg_alpha")}});
}

void {{ solver.struct_name }}::do_update_step_first() {
    {% for nodetype in solver.node_types %}
    {{nodetype.__name__}}_update_step_first(
        {{node_key(nodetype, "p")}}, {{num_key(nodetype)}},
        {{solver_key("alpha")}},
        {{node_key(nodetype, "step")}}, {{num_key(nodetype)}},
        {{num_key(nodetype)}}
    );
    {% endfor %}
}

void {{ solver.struct_name }}::do_update_step() {
    {% for nodetype in solver.node_types %}
    {{nodetype.__name__}}_update_step(
        {{node_key(nodetype, "step")}}, {{num_key(nodetype)}},
        {{node_key(nodetype, "p")}}, {{num_key(nodetype)}},
        {{solver_key("alpha")}},
        {{node_key(nodetype, "step")}}, {{num_key(nodetype)}},
        {{num_key(nodetype)}}
    );
    {% endfor %}
}

void {{ solver.struct_name }}::do_update_r_first() {
    zero({{solver_key("r_0_norm2_tot")}}, {{solver_key("r_0_norm2_tot")}}+1);

    {% for nodetype in solver.node_types %}
    {{nodetype.__name__}}_update_r_first(
        {{node_key(nodetype, "r_k")}}, {{num_key(nodetype)}},
        {{node_key(nodetype, "w")}}, {{num_key(nodetype)}},
        {{solver_key("neg_alpha")}},
        {{node_key(nodetype, "r_k")}}, {{num_key(nodetype)}},
        {{solver_key("r_0_norm2_tot")}},
        {{solver_key("r_kp1_norm2_tot")}},
        {{num_key(nodetype)}}
    );

    {% endfor %}
    pcg_r_0_norm2_ = read_cumem({{solver_key("r_0_norm2_tot")}});
    pcg_r_kp1_norm2_ = read_cumem({{solver_key("r_kp1_norm2_tot")}});
}

void {{ solver.struct_name }}::do_update_r() {
    zero({{solver_key("r_kp1_norm2_tot")}}, {{solver_key("r_kp1_norm2_tot")}}+1);

    {% for nodetype in solver.node_types %}
    {{nodetype.__name__}}_update_r(
        {{node_key(nodetype, "r_k")}}, {{num_key(nodetype)}},
        {{node_key(nodetype, "w")}}, {{num_key(nodetype)}},
        {{solver_key("neg_alpha")}},
        {{node_key(nodetype, "r_k")}}, {{num_key(nodetype)}},
        {{solver_key("r_kp1_norm2_tot")}},
        {{num_key(nodetype)}}
    );
    {% endfor %}
    pcg_r_kp1_norm2_ = read_cumem({{solver_key("r_kp1_norm2_tot")}});
}

{{solver.linear_t}} {{ solver.struct_name }}::do_retract_score() {
    {% for nodetype in solver.node_types %}
    {{nodetype.__name__}}_retract(
        {{node_key(nodetype, "storage_current")}}, {{num_max_key(nodetype)}},
        {{node_key(nodetype, "step")}}, {{num_key(nodetype)}},
        {{node_key(nodetype, "storage_check")}}, {{num_max_key(nodetype)}},
        {{num_key(nodetype)}}
    );
    {% endfor %}

    zero({{solver_key("res_tot")}}, {{solver_key("res_tot")}}+1);
    {% for fac in solver.factors %}
    {{fac.name}}_score(
        {% for arg, typ in fac.arg_types.items() %}
          {% if fac.isnode[arg] %}
            {% if fac.isnodepair[arg] %}
                {{node_key(typ, "storage_check")}},
                {{num_max_key(typ)}},
            {% elif fac.isnodeuniq[arg] %}
                {{node_key(typ, "storage_check")}},
            {% elif fac.isnodeshared[arg] %}
                {{node_key(typ, "storage_check")}},
                {{num_max_key(typ)}},
                {{arg_key(fac, arg, "idx_shared")}},
            {% endif %}
          {% else %}
            {% if fac.isconstseq[arg] %}
                {{arg_key(fac, arg, "data")}},
                {{num_max_key(fac)}},
            {% elif fac.isconstshared[arg] %}
                {{arg_key(fac, arg, "data")}}, {{num_max_key(fac)}}, {{arg_key(fac, arg, "idx_shared")}},
            {% elif fac.isconstindexed[arg] %}
                {{arg_key(fac, arg, "data")}}, {{num_max_key(fac)}}, {{arg_key(fac, arg, "idx")}},
            {% elif fac.isconstuniq[arg] %}
                {{arg_key(fac, arg, "data")}},
            {% endif %}
          {% endif %}
        {% endfor %}
        {{solver_key("res_tot")}},
        {{num_key(fac)}}
    );
    {% endfor %}
    return 0.5 * read_cumem({{solver_key("res_tot")}});
}

void {{ solver.struct_name }}::do_beta() {
    zero({{solver_key("beta_numerator")}}, {{solver_key("beta_numerator")}}+1);
    {% for nodetype in solver.node_types %}

    {{nodetype.__name__}}_alpha_denumerator_or_beta_nummerator(
        {{node_key(nodetype, "r_k")}}, {{num_key(nodetype)}},
        {{node_key(nodetype, "z")}}, {{num_key(nodetype)}},
        {{solver_key("beta_numerator")}},
        {{num_key(nodetype)}}
    );
    {% endfor %}
    beta_from_num_denum({{solver_key("beta_numerator")}}, {{solver_key("alpha_numerator")}}, {{solver_key("beta")}});
}

void {{ solver.struct_name }}::do_update_p() {
    {% for nodetype in solver.node_types %}
    {{nodetype.__name__}}_update_p(
        {{node_key(nodetype, "z")}}, {{num_key(nodetype)}},
        {{node_key(nodetype, "p")}}, {{num_key(nodetype)}},
        {{solver_key("beta")}},
        {{node_key(nodetype, "p")}}, {{num_key(nodetype)}},
        {{num_key(nodetype)}}
    );
    {% endfor %}
}

{{solver.linear_t}} {{ solver.struct_name }}::get_pred_decrease() {
    zero({{solver_key("pred_decrease_tot")}}, {{solver_key("pred_decrease_tot")}}+1);
    {% for nodetype in solver.node_types %}
    {{nodetype.__name__}}_pred_decrease_times_two(
        {{node_key(nodetype, "step")}}, {{num_key(nodetype)}},
        {{node_key(nodetype, "precond_diag")}}, {{num_key(nodetype)}},
        {{solver_key("current_diag")}},
        {{node_key(nodetype, "r_0")}}, {{num_key(nodetype)}},
        {{solver_key("pred_decrease_tot")}},
        {{num_key(nodetype)}}
    );
    {% endfor %}
    return 0.5 * read_cumem({{solver_key("pred_decrease_tot")}});
}

void {{ solver.struct_name }}::finish_indices() {
    {# {% for fac in solver.factors %}
      {% if not fac.isnodepair[fac.prioritized_node] %}
        {% for arg, argtype in fac.node_arg_types.items() %}
          {% if arg != fac.prioritized_node %}
          select_index({{arg_key(fac, fac.prioritized_node, "idx_target")}},
                      {{arg_key(fac, arg, "idx_argsort")}},
                      {{arg_key(fac, arg, "idx_jp_target")}},
                      {{num_key(fac)}});
          {% endif %}
        {% endfor %}
      {% endif %}
    {% endfor %} #}
    indices_valid_ = true;
}

{% for nodetype in solver.node_types %}
void {{ solver.struct_name }}::set_{{num_key(nodetype)[:-1]}}(const size_t num) {
    if (num > {{num_max_key(nodetype)}}) {
        throw std::runtime_error(std::to_string(num) + " > {{num_max_key(nodetype)}}");
    }
    {{num_key(nodetype)}} = num;
}

void {{ solver.struct_name }}::set_{{nodetype.__name__}}_nodes_from_stacked_host(
    const {{solver.storage_t}}* const data, const size_t offset, const size_t num) {
  if (offset + num > {{num_key(nodetype)}}){
    throw std::runtime_error(std::to_string(offset + num) + " > {{num_key(nodetype)}}");
  }
  cudaMemcpy(marker__scratch_inout_, data, {{Ops.storage_dim(nodetype)}} * num * sizeof({{solver.storage_t}}),
             cudaMemcpyHostToDevice);
  {{nodetype.__name__}}_stacked_to_caspar(marker__scratch_inout_,
                                          {{node_key(nodetype, "storage_current")}},
                                          {{num_max_key(nodetype)}}, offset, num);
}

void {{ solver.struct_name }}::set_{{nodetype.__name__}}_nodes_from_stacked_device(
    const {{solver.storage_t}}* const data, const size_t offset, const size_t num) {
  if (offset + num > {{num_key(nodetype)}}){
    throw std::runtime_error(std::to_string(offset + num) + " > {{num_key(nodetype)}}");
  }
  {{nodetype.__name__}}_stacked_to_caspar(
      data, {{node_key(nodetype, "storage_current")}}, {{num_max_key(nodetype)}}, offset, num);
}

void {{solver.struct_name}}::get_{{nodetype.__name__}}_nodes_to_stacked_host(
    {{solver.storage_t}}* const data, const size_t offset, const size_t num) {
  if (offset + num > {{num_key(nodetype)}}){
    throw std::runtime_error(std::to_string(offset + num) + " > {{num_key(nodetype)}}");
  }
  {{nodetype.__name__}}_caspar_to_stacked({{node_key(nodetype, "storage_current")}},
                                          marker__scratch_inout_, {{num_max_key(nodetype)}},
                                          offset, num);
  cudaMemcpy(data, marker__scratch_inout_, {{Ops.storage_dim(nodetype)}} * num * sizeof({{solver.storage_t}}),
             cudaMemcpyDeviceToHost);
}

void {{solver.struct_name}}::get_{{nodetype.__name__}}_nodes_to_stacked_device(
    {{solver.storage_t}}* const data, const size_t offset, const size_t num) {
  if (offset + num > {{num_key(nodetype)}}){
    throw std::runtime_error(std::to_string(offset + num) + " > {{num_key(nodetype)}}");
  }
  {{nodetype.__name__}}_caspar_to_stacked({{node_key(nodetype, "storage_current")}}, data,
                                          {{num_max_key(nodetype)}}, offset, num);
}

{% endfor%}

{% for fac in solver.factors %}
  void {{ solver.struct_name }}::set_{{num_key(fac)[:-1]}}(const size_t num) {
    if (num > {{num_max_key(fac)}}){
      throw std::runtime_error(std::to_string(num) + " > {{num_max_key(fac)}}");
    }
    {{num_key(fac)}} = num;
  }
  {% for arg, argtype in fac.node_arg_types.items() %}
    {% if fac.isnodeshared[arg] %}
      void {{ solver.struct_name }}::set_{{fac.name}}_{{arg}}_indices_from_host(
          const unsigned int* const indices, size_t num) {
        if (num != {{num_key(fac)}}){
          throw std::runtime_error(
              std::to_string(num)
              + " != {{num_key(fac)}}. Use set_{{fac.name}}_num before setting indices.");
        }
        cudaMemcpy((unsigned int*)marker__scratch_inout_, indices, num * sizeof(unsigned int),
                  cudaMemcpyHostToDevice);
        set_{{fac.name}}_{{arg}}_indices_from_device((unsigned int*)marker__scratch_inout_, num);
      }

      void {{ solver.struct_name }}::set_{{fac.name}}_{{arg}}_indices_from_device(
          const unsigned int* const indices, size_t num) {
        indices_valid_ = false;

        if (num != {{num_key(fac)}}){
          throw std::runtime_error(
              std::to_string(num)
              + " != {{num_key(fac)}}. Use set_{{fac.name}}_num before setting indices.");
        }

        size_t tmp_size = sort_indices_get_tmp_nbytes(num);
        if (tmp_size + num > scratch_inout_size_) {
            throw std::runtime_error("Scratch_inout_size too small. tmp_size: " + std::to_string(tmp_size) +
                                    ", num: " + std::to_string(num) +
                                    ", scratch_inout_size_: " + std::to_string(scratch_inout_size_));
        }
        shared_indices(indices, {{arg_key(fac, arg, "idx_shared")}}, num);
      }
    {% endif %}
  {% endfor %}
  {% for arg, argtype in fac.const_arg_types.items() %}
    void {{ solver.struct_name }}::set_{{fac.name}}_{{arg}}_data_from_stacked_host(
          {% if fac.isconstseq[arg] %}
          const {{solver.storage_t}}* const data, size_t offset, size_t num
          {% elif fac.isconstuniq[arg] %}
          const {{solver.storage_t}}* const data
          {% elif fac.isconstshared[arg] %}
          const {{solver.storage_t}}* const data, size_t offset, size_t num
          {% elif fac.isconstindexed[arg] %}
          const {{solver.storage_t}}* const data, size_t offset, size_t num
          {% endif %}
          ) {
      {% if fac.isconstuniq[arg] %}
      const size_t offset = 0;
      const size_t num = 1;
      {% endif %}
      if (offset + num > {{num_max_key(fac)}}) {
          throw std::runtime_error(std::to_string(offset + num) + " > {{num_max_key(fac)}}");
      }
      cudaMemcpy(marker__scratch_inout_, data, {{Ops.storage_dim(argtype)}} * num * sizeof({{solver.storage_t}}),
                cudaMemcpyHostToDevice);
      {{argtype.__name__}}_stacked_to_caspar(marker__scratch_inout_, {{arg_key(fac, arg, "data")}},
                                            {% if fac.isconstseq[arg] %}
                                            {{num_max_key(fac)}},
                                            {% elif fac.isconstuniq[arg] %}
                                            1,
                                            {% elif fac.isconstshared[arg] %}
                                            {{num_max_key(fac)}},
                                            {% elif fac.isconstindexed[arg] %}
                                            {{num_max_key(fac)}},
                                            {% endif %}
                                            offset, num);
    }

    void {{ solver.struct_name }}::set_{{fac.name}}_{{arg}}_data_from_stacked_device(
          {% if fac.isconstseq[arg] %}
          const {{solver.storage_t}}* const data, size_t offset, size_t num
          {% elif fac.isconstuniq[arg] %}
          const {{solver.storage_t}}* const data
          {% elif fac.isconstshared[arg] %}
            const {{solver.storage_t}}* const data, size_t offset, size_t num
          {% elif fac.isconstindexed[arg] %}
            const {{solver.storage_t}}* const data, size_t offset, size_t num
          {% endif %}        ) {
      {% if fac.isconstuniq[arg] %}
      const size_t offset = 0;
      const size_t num = 1;
      {% endif %}
      if (offset + num > {{num_max_key(fac)}}){
        throw std::runtime_error(std::to_string(offset + num) + " > {{num_max_key(fac)}}");
      }
      {{argtype.__name__}}_stacked_to_caspar(data, {{arg_key(fac, arg, "data")}},
                                            {% if fac.isconstseq[arg] %}
                                            {{num_max_key(fac)}},
                                            {% elif fac.isconstuniq[arg] %}
                                            1,
                                            {% elif fac.isconstshared[arg] %}
                                            {{num_max_key(fac)}},
                                            {% elif fac.isconstindexed[arg] %}
                                            {{num_max_key(fac)}},
                                            {% endif %}
                                            offset, num);
    }
    {% if fac.isconstshared[arg] %}
      void {{ solver.struct_name }}::set_{{fac.name}}_{{arg}}_indices_from_host(
            const unsigned int* const indices, size_t num) {
          if (num != {{num_key(fac)}}){
            throw std::runtime_error(
                std::to_string(num)
                + " != {{num_key(fac)}}. Use set_{{fac.name}}_num before setting indices.");
          }
          cudaMemcpy((unsigned int*)marker__scratch_inout_, indices, num * sizeof(unsigned int),
                    cudaMemcpyHostToDevice);
          set_{{fac.name}}_{{arg}}_indices_from_device((unsigned int*)marker__scratch_inout_, num);
        }

        void {{ solver.struct_name }}::set_{{fac.name}}_{{arg}}_indices_from_device(
            const unsigned int* const indices, size_t num) {
          indices_valid_ = false;

          if (num != {{num_key(fac)}}){
            throw std::runtime_error(
                std::to_string(num)
                + " != {{num_key(fac)}}. Use set_{{fac.name}}_num before setting indices.");
          }

          size_t tmp_size = sort_indices_get_tmp_nbytes(num);
          if (tmp_size + num > scratch_inout_size_) {
              throw std::runtime_error("Scratch_inout_size too small. tmp_size: " + std::to_string(tmp_size) +
                                      ", num: " + std::to_string(num) +
                                      ", scratch_inout_size_: " + std::to_string(scratch_inout_size_));
          }


          shared_indices(indices, {{arg_key(fac, arg, "idx_shared")}}, num);

        }
    {% elif fac.isconstindexed[arg] %}
      void {{ solver.struct_name }}::set_{{fac.name}}_{{arg}}_indices_from_host(
            const unsigned int* const indices, size_t num) {
          indices_valid_ = false;
          if (num != {{num_key(fac)}}){
            throw std::runtime_error(
                std::to_string(num)
                + " != {{num_key(fac)}}. Use set_{{fac.name}}_num before setting indices.");
          }
          cudaMemcpy({{arg_key(fac, arg, "idx")}}, indices, num * sizeof(unsigned int),
                    cudaMemcpyHostToDevice);
        }

        void {{ solver.struct_name }}::set_{{fac.name}}_{{arg}}_indices_from_device(
            const unsigned int* const indices, size_t num) {
          indices_valid_ = false;
          if (num != {{num_key(fac)}}){
            throw std::runtime_error(
                std::to_string(num)
                + " != {{num_key(fac)}}. Use set_{{fac.name}}_num before setting indices.");
          }
          cudaMemcpy({{arg_key(fac, arg, "idx")}}, indices, num * sizeof(unsigned int),
                    cudaMemcpyDeviceToDevice);
        }

    {% endif%}
  {% endfor%}
{% endfor%}

size_t {{ solver.struct_name }}::get_nbytes() {
    size_t offset = 0;
    size_t at_least = 0;
    {% for name, field in solver.fields.items()%}
    {% if name in solver.at_least %}
    at_least = std::max(at_least, offset + {{solver.at_least[name]}}*sizeof({{field.dtype}}));
    {% endif %}
    increment_offset<{{field.dtype}}>(offset, {{field.dim_real}} * {{field.num_key}},
                                      {{field.alignment}});
    {% endfor %}

    return std::max(offset, at_least);
}

} // namespace caspar
