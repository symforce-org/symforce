# -----------------------------------------------------------------------------
# This file was autogenerated by symforce from template:
#     cc_sym.pyi.jinja
# Do NOT modify by hand.
# -----------------------------------------------------------------------------

import scipy

from lcmtypes.sym._index_entry_t import index_entry_t
from lcmtypes.sym._index_t import index_t
from lcmtypes.sym._key_t import key_t
from lcmtypes.sym._linearized_dense_factor_t import linearized_dense_factor_t
from lcmtypes.sym._optimization_iteration_t import optimization_iteration_t
from lcmtypes.sym._optimization_stats_t import optimization_stats_t
from lcmtypes.sym._optimization_status_t import optimization_status_t
from lcmtypes.sym._optimizer_params_t import optimizer_params_t
from lcmtypes.sym._sparse_matrix_structure_t import sparse_matrix_structure_t
from lcmtypes.sym._values_t import values_t

from sym import ATANCameraCal
from sym import DoubleSphereCameraCal
from sym import EquirectangularCameraCal
from sym import LinearCameraCal
from sym import PolynomialCameraCal
from sym import Pose2
from sym import Pose3
from sym import Rot2
from sym import Rot3
from sym import SphericalCameraCal
from sym import Unit3

# isort: off

"""This module wraps many of the C++ optimization classes."""
from __future__ import annotations
import cc_sym
import typing
import numpy

__all__ = [
    "Factor",
    "Key",
    "Linearization",
    "OptimizationStats",
    "Optimizer",
    "Values",
    "default_optimizer_params",
    "optimize",
    "set_log_level",
]

class Factor:
    """
    A residual term for optimization.

    Created from a function and a set of Keys that act as inputs. Given a Values as an evaluation
    point, generates a linear approximation to the residual function.
    """
    @typing.overload
    def __init__(
        self,
        hessian_func: typing.Callable[[Values, typing.List[index_entry_t]], tuple],
        keys: typing.List[Key],
        sparse: bool = False,
    ) -> None:
        """
        Create directly from a hessian functor. This is the lowest-level constructor.

        Args:
          keys: The set of input arguments, in order, accepted by func.
          sparse: Create a sparse factor if True, dense factor if false. Defaults to dense.

        Precondition:
          The jacobian and hessian returned by hessian_func have type scipy.sparse.csc_matrix if and only if sparse = True.



        Create directly from a hessian functor. This is the lowest-level constructor.

        Args:
          keys_to_func: The set of input arguments, in order, accepted by func.
          keys_to_optimize: The set of input arguments that correspond to the derivative in func. Must be a subset of keys_to_func.
          sparse: Create a sparse factor if True, dense factor if false. Defaults to dense.

        Precondition:
          The jacobian and hessian returned by hessian_func have type scipy.sparse.csc_matrix if and only if sparse = True.
        """
    @typing.overload
    def __init__(
        self,
        hessian_func: typing.Callable[[Values, typing.List[index_entry_t]], tuple],
        keys_to_func: typing.List[Key],
        keys_to_optimize: typing.List[Key],
        sparse: bool = False,
    ) -> None: ...
    def __repr__(self) -> str: ...
    def all_keys(self) -> typing.List[Key]:
        """
        Get all keys required to evaluate this factor.
        """
    def is_sparse(self) -> bool:
        """
        Does this factor use a sparse jacobian/hessian matrix?
        """
    @staticmethod
    @typing.overload
    def jacobian(
        jacobian_func: typing.Callable[[Values, typing.List[index_entry_t]], tuple],
        keys: typing.List[Key],
        sparse: bool = False,
    ) -> Factor:
        """
        Create from a function that computes the jacobian. The hessian will be computed using the
        Gauss Newton approximation::

            H   = J.T * J
            rhs = J.T * b

        Args:
          keys: The set of input arguments, in order, accepted by func.
          sparse: Create a sparse factor if True, dense factor if false. Defaults to dense.

        Precondition:
          The jacobian returned by jacobian_func has type scipy.sparse.csc_matrix if and only if sparse = True.



        Create from a function that computes the jacobian. The hessian will be computed using the
        Gauss Newton approximation::

            H   = J.T * J
            rhs = J.T * b

        Args:
          keys_to_func: The set of input arguments, in order, accepted by func.
          keys_to_optimize: The set of input arguments that correspond to the derivative in func. Must be a subset of keys_to_func.
          sparse: Create a sparse factor if True, dense factor if false. Defaults to dense.

          Precondition:
            The jacobian returned by jacobian_func has type scipy.sparse.csc_matrix if and only if sparse = True.
        """
    @staticmethod
    @typing.overload
    def jacobian(
        jacobian_func: typing.Callable[[Values, typing.List[index_entry_t]], tuple],
        keys_to_func: typing.List[Key],
        keys_to_optimize: typing.List[Key],
        sparse: bool = False,
    ) -> Factor: ...
    def linearize(self, arg0: Values) -> tuple:
        """
        Evaluate the factor at the given linearization point and output just the numerical values of the residual and jacobian.
        """
    def linearized_factor(self, values: Values) -> linearized_dense_factor_t:
        """
        Evaluate the factor at the given linearization point and output a LinearizedDenseFactor that
        contains the numerical values of the residual, jacobian, hessian, and right-hand-side.

        This can only be called if is_sparse is false; otherwise, it will throw.
        """
    def optimized_keys(self) -> typing.List[Key]:
        """
        Get the optimized keys for this factor.
        """
    pass

class Key:
    """
    Key type for Values. Contains a letter plus an integral subscript and superscript. Can construct with a letter, a letter + sub, or a letter + sub + super, but not a letter + super.
    """
    def __eq__(self, arg0: object) -> bool: ...
    def __getstate__(self) -> tuple: ...
    def __hash__(self) -> int: ...
    @typing.overload
    def __init__(self, letter: str) -> None: ...
    @typing.overload
    def __init__(self, letter: str, sub: int) -> None: ...
    @typing.overload
    def __init__(self, letter: str, sub: int, super: int) -> None: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: tuple) -> None: ...
    def get_lcm_type(self) -> key_t: ...
    def lexical_less_than(self, arg0: Key) -> bool:
        """
        Return true if a is LESS than b, in dictionary order of the tuple (letter, sub, super).
        """
    def with_letter(self, letter: str) -> Key:
        """
        Creates a new key with a modified letter from an existing one.
        """
    def with_sub(self, sub: int) -> Key:
        """
        Creates a new key with a modified subscript from an existing one.
        """
    def with_super(self, super: int) -> Key:
        """
        Creates a new key with a modified superscript from an existing one.
        """
    @property
    def letter(self) -> str:
        """
        The letter value of the key.

        :type: str
        """
    @property
    def sub(self) -> int:
        """
        The subscript value of the key (INVALID_SUB if not set).

        :type: int
        """
    @property
    def super(self) -> int:
        """
        The superscript value of the key (INVALID_SUPER if not set).

        :type: int
        """
    INVALID_LETTER = "\x00"
    INVALID_SUB = -9223372036854775808
    INVALID_SUPER = -9223372036854775808
    pass

class Linearization:
    """
    Class for storing a problem linearization evaluated at a Values (i.e. a residual, jacobian, hessian, and rhs).
    """
    def __getstate__(self) -> tuple: ...
    def __init__(self) -> None: ...
    def __setstate__(self, arg0: tuple) -> None: ...
    def error(self) -> float: ...
    def is_initialized(self) -> bool:
        """
        Returns whether the linearization is currently valid for the corresponding values. Accessing any of the members when this is false could result in unexpected behavior.
        """
    def linear_delta_error(
        self, x_update: numpy.ndarray, damping_vector: numpy.ndarray
    ) -> float: ...
    def reset(self) -> None:
        """
        Set to invalid.
        """
    def set_initialized(self, initialized: bool = True) -> None: ...
    @property
    def hessian_lower(self) -> scipy.sparse.csc_matrix[numpy.float64]:
        """
        :type: scipy.sparse.csc_matrix[numpy.float64]
        """
    @hessian_lower.setter
    def hessian_lower(self, arg0: scipy.sparse.csc_matrix[numpy.float64]) -> None:
        pass
    @property
    def jacobian(self) -> scipy.sparse.csc_matrix[numpy.float64]:
        """
        :type: scipy.sparse.csc_matrix[numpy.float64]
        """
    @jacobian.setter
    def jacobian(self, arg0: scipy.sparse.csc_matrix[numpy.float64]) -> None:
        pass
    @property
    def residual(self) -> numpy.ndarray:
        """
        :type: numpy.ndarray
        """
    @residual.setter
    def residual(self, arg0: numpy.ndarray) -> None:
        pass
    @property
    def rhs(self) -> numpy.ndarray:
        """
        :type: numpy.ndarray
        """
    @rhs.setter
    def rhs(self, arg0: numpy.ndarray) -> None:
        pass
    pass

class OptimizationStats:
    """
    Debug stats for a full optimization run.
    """
    def __getstate__(self) -> tuple: ...
    def __init__(self) -> None: ...
    def __setstate__(self, arg0: tuple) -> None: ...
    def get_lcm_type(self) -> optimization_stats_t: ...
    @property
    def best_index(self) -> int:
        """
        Index into iterations of the best iteration (containing the optimal Values).

        :type: int
        """
    @best_index.setter
    def best_index(self, arg0: int) -> None:
        """
        Index into iterations of the best iteration (containing the optimal Values).
        """
    @property
    def best_linearization(self) -> typing.Optional[Linearization]:
        """
        The linearization at best_index (at optimized_values), filled out if populate_best_linearization=True

        :type: object
        """
    @best_linearization.setter
    def best_linearization(self, arg1: Linearization) -> None:
        """
        The linearization at best_index (at optimized_values), filled out if populate_best_linearization=True
        """
    @property
    def cholesky_factor_sparsity(self) -> sparse_matrix_structure_t:
        """
        Sparsity pattern of the cholesky factor L (filled out if debug_stats=True)

        :type: sparse_matrix_structure_t
        """
    @cholesky_factor_sparsity.setter
    def cholesky_factor_sparsity(self, arg0: sparse_matrix_structure_t) -> None:
        """
        Sparsity pattern of the cholesky factor L (filled out if debug_stats=True)
        """
    @property
    def failure_reason(self) -> int:
        """
        If status == FAILED, why?  This should be cast to the NonlinearSolver::FailureReason enum for the nonlinear solver you used.

        :type: int
        """
    @failure_reason.setter
    def failure_reason(self, arg0: int) -> None:
        """
        If status == FAILED, why?  This should be cast to the NonlinearSolver::FailureReason enum for the nonlinear solver you used.
        """
    @property
    def iterations(self) -> typing.List[optimization_iteration_t]:
        """
        :type: typing.List[optimization_iteration_t]
        """
    @iterations.setter
    def iterations(self, arg0: typing.List[optimization_iteration_t]) -> None:
        pass
    @property
    def jacobian_sparsity(self) -> sparse_matrix_structure_t:
        """
        Sparsity pattern of the problem jacobian (filled out if debug_stats=True and include_jacobians=True)

        :type: sparse_matrix_structure_t
        """
    @jacobian_sparsity.setter
    def jacobian_sparsity(self, arg0: sparse_matrix_structure_t) -> None:
        """
        Sparsity pattern of the problem jacobian (filled out if debug_stats=True and include_jacobians=True)
        """
    @property
    def linear_solver_ordering(self) -> typing.Any:
        """
        Ordering used by the linear solver (filled out if debug_stats=True)

        :type: typing.Any
        """
    @linear_solver_ordering.setter
    def linear_solver_ordering(self, arg0: typing.Any) -> None:
        """
        Ordering used by the linear solver (filled out if debug_stats=True)
        """
    @property
    def status(self) -> optimization_status_t:
        """
        What was the result of the optimization? (did it converge, fail, etc.)

        :type: optimization_status_t
        """
    @status.setter
    def status(self, arg0: optimization_status_t) -> None:
        """
        What was the result of the optimization? (did it converge, fail, etc.)
        """
    pass

class Optimizer:
    """
    Class for optimizing a nonlinear least-squares problem specified as a list of Factors. For efficient use, create once and call Optimize() multiple times with different initial guesses, as long as the factors remain constant and the structure of the Values is identical.
    """
    def __init__(
        self,
        params: optimizer_params_t,
        factors: typing.List[Factor],
        name: str = "sym::Optimize",
        keys: typing.List[Key] = [],
        epsilon: float = 2.220446049250313e-15,
    ) -> None: ...
    def compute_all_covariances(
        self, linearization: Linearization
    ) -> typing.Dict[Key, numpy.ndarray]:
        """
        Get covariances for each optimized key at the given linearization

        May not be called before either optimize or linearize has been called.
        """
    def compute_covariances(
        self, linearization: Linearization, keys: typing.List[Key]
    ) -> typing.Dict[Key, numpy.ndarray]:
        """
        Get covariances for the given subset of keys at the given linearization

        This version is potentially much more efficient than computing the covariances for all
        keys in the problem.

        Currently requires that `keys` corresponds to a set of keys at the start of the list of keys
        for the full problem, and in the same order.  It uses the Schur complement trick, so will be
        most efficient if the hessian is of the following form, with C block diagonal::

            A = ( B    E )
                ( E^T  C )
        """
    def compute_full_covariance(self, linearization: Linearization) -> numpy.ndarray:
        """
        Get the full problem covariance at the given linearization

        Unlike compute_covariance and compute_all_covariances, this includes the off-diagonal
        blocks, i.e. the cross-covariances between different keys.

        The ordering of entries here is the same as the ordering of the keys in the linearization,
        which can be accessed via linearization_index().

        May not be called before either optimize or linearize has been called.
        """
    def factors(self) -> typing.List[Factor]:
        """
        Get the factors.
        """
    def keys(self) -> typing.List[Key]:
        """
        Get the optimized keys.
        """
    def linearization_index(self) -> dict: ...
    def linearization_index_entry(self, key: Key) -> index_entry_t: ...
    def linearize(self, values: Values) -> Linearization:
        """
        Linearize the problem around the given values.
        """
    @typing.overload
    def optimize(
        self, values: Values, num_iterations: int = -1, populate_best_linearization: bool = False
    ) -> OptimizationStats:
        """
        Optimize the given values in-place

        Args:
          num_iterations: If < 0 (the default), uses the number of iterations specified by the params at construction.

          populate_best_linearization: If true, the linearization at the best values will be filled out in the stats.

        Returns:
            The optimization stats



        Optimize the given values in-place

        This overload takes the stats as an argument, and stores into there.  This allows users to
        avoid reallocating memory for any of the entries in the stats, for use cases where that's
        important.  If passed, stats must not be None.

        Args:
          num_iterations: If < 0 (the default), uses the number of iterations specified by the params at construction

          populate_best_linearization: If true, the linearization at the best values will be filled out in the stats

          stats: An OptimizationStats to fill out with the result - if filling out dynamically allocated fields here, will not reallocate if memory is already allocated in the required shape (e.g. for repeated calls to Optimize)



        Optimize the given values in-place

        This overload takes the stats as an argument, and stores into there.  This allows users to
        avoid reallocating memory for any of the entries in the stats, for use cases where that's
        important.  If passed, stats must not be None.

        Args:
          num_iterations: If < 0 (the default), uses the number of iterations specified by the params at construction

          stats: An OptimizationStats to fill out with the result - if filling out dynamically allocated fields here, will not reallocate if memory is already allocated in the required shape (e.g. for repeated calls to Optimize)



        Optimize the given values in-place

        This overload takes the stats as an argument, and stores into there.  This allows users to
        avoid reallocating memory for any of the entries in the stats, for use cases where that's
        important.  If passed, stats must not be None.

        Args:
          stats: An OptimizationStats to fill out with the result - if filling out dynamically allocated fields here, will not reallocate if memory is already allocated in the required shape (e.g. for repeated calls to Optimize)
        """
    @typing.overload
    def optimize(
        self,
        values: Values,
        num_iterations: int,
        populate_best_linearization: bool,
        stats: OptimizationStats,
    ) -> None: ...
    @typing.overload
    def optimize(self, values: Values, num_iterations: int, stats: OptimizationStats) -> None: ...
    @typing.overload
    def optimize(self, values: Values, stats: OptimizationStats) -> None: ...
    def update_params(self, params: optimizer_params_t) -> None:
        """
        Update the optimizer params.
        """
    pass

class Values:
    """
    Efficient polymorphic data structure to store named types with a dict-like interface and
    support efficient repeated operations using a key index. Supports on-manifold optimization.

    Compatible types are given by the type_t enum. All types implement the StorageOps and
    LieGroupOps concepts, which are the core operating mechanisms in this class.
    """
    def __getstate__(self) -> bytes: ...
    @typing.overload
    def __init__(self) -> None:
        """
        Default construct as empty.

        Construct from serialized form.
        """
    @typing.overload
    def __init__(self, msg: values_t) -> None: ...
    def __repr__(self) -> str: ...
    def __setstate__(self, arg0: bytes) -> None: ...
    @typing.overload
    def at(self, key: Key) -> typing.Any:
        """
        Retrieve a value by key.

        Retrieve a value by index entry. This avoids a map lookup compared to at(key).
        """
    @typing.overload
    def at(self, entry: index_entry_t) -> typing.Any: ...
    def cleanup(self) -> int:
        """
        Repack the data array to get rid of empty space from removed keys. If regularly removing
        keys, it's up to the user to call this appropriately to avoid storage growth. Returns the
        number of Scalar elements cleaned up from the data array.

        It will INVALIDATE all indices, offset increments, and pointers.
        Re-create an index with create_index().
        """
    def create_index(self, keys: typing.List[Key]) -> index_t:
        """
        Create an index from the given ordered subset of keys. This object can then be used
        for repeated efficient operations on that subset of keys.

        If you want an index of all the keys, call `values.create_index(values.keys())`.

        An index will be INVALIDATED if the following happens:
          1) remove() is called with a contained key, or remove_all() is called
          2) cleanup() is called to re-pack the data array
        """
    def data(self) -> typing.List[float]:
        """
        Raw data buffer.
        """
    def empty(self) -> bool:
        """
        Has zero keys.
        """
    def get_lcm_type(self, sort_keys: bool = False) -> values_t:
        """
        Serialize to LCM.
        """
    def has(self, key: Key) -> bool:
        """
        Return whether the key exists.
        """
    def items(self) -> typing.Dict[Key, index_entry_t]:
        """
        Expose map type to allow iteration.
        """
    def keys(self, sort_by_offset: bool = True) -> typing.List[Key]:
        """
        Get all keys.

        Args:
            sort_by_offset: Sorts by storage order to make iteration safer and more memory efficient
        """
    def local_coordinates(self, others: Values, index: index_t, epsilon: float) -> numpy.ndarray:
        """
        Express this Values in the local coordinate of others Values, i.e., this \ominus others

        Args:
            others: The other Values that the local coordinate is relative to
            index: Ordered list of keys to include (MUST be valid for both this and others Values)
            epsilon: Small constant to avoid singularities (do not use zero)

        """
    def num_entries(self) -> int:
        """
        Number of keys.
        """
    def remove(self, key: Key) -> bool:
        """
        Remove the given key. Only removes the index entry, does not change the data array.
        Returns true if removed, false if already not present.

        Call cleanup() to re-pack the data array.
        """
    def remove_all(self) -> None:
        """
        Remove all keys and empty out the storage.
        """
    def retract(self, index: index_t, delta: typing.List[float], epsilon: float) -> None:
        """
        Perform a retraction from an update vector.

        Args:
            index: Ordered list of keys in the delta vector
            delta: Update vector - MUST be the size of index.tangent_dim!
            epsilon: Small constant to avoid singularities (do not use zero)
        """
    @typing.overload
    def set(self, key: Key, value: float) -> bool:
        """
        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.

        Add or update a value by key. Returns true if added, false if updated.

        Update a value by index entry with no map lookup (compared to Set(key)). This does NOT add new values and assumes the key exists already.
        """
    @typing.overload
    def set(self, key: index_entry_t, value: float) -> None: ...
    @typing.overload
    def set(self, key: Key, value: Rot2) -> bool: ...
    @typing.overload
    def set(self, key: index_entry_t, value: Rot2) -> None: ...
    @typing.overload
    def set(self, key: Key, value: Rot3) -> bool: ...
    @typing.overload
    def set(self, key: index_entry_t, value: Rot3) -> None: ...
    @typing.overload
    def set(self, key: Key, value: Pose2) -> bool: ...
    @typing.overload
    def set(self, key: index_entry_t, value: Pose2) -> None: ...
    @typing.overload
    def set(self, key: Key, value: Pose3) -> bool: ...
    @typing.overload
    def set(self, key: index_entry_t, value: Pose3) -> None: ...
    @typing.overload
    def set(self, key: Key, value: Unit3) -> bool: ...
    @typing.overload
    def set(self, key: index_entry_t, value: Unit3) -> None: ...
    @typing.overload
    def set(self, key: Key, value: ATANCameraCal) -> bool: ...
    @typing.overload
    def set(self, key: index_entry_t, value: ATANCameraCal) -> None: ...
    @typing.overload
    def set(self, key: Key, value: DoubleSphereCameraCal) -> bool: ...
    @typing.overload
    def set(self, key: index_entry_t, value: DoubleSphereCameraCal) -> None: ...
    @typing.overload
    def set(self, key: Key, value: EquirectangularCameraCal) -> bool: ...
    @typing.overload
    def set(self, key: index_entry_t, value: EquirectangularCameraCal) -> None: ...
    @typing.overload
    def set(self, key: Key, value: LinearCameraCal) -> bool: ...
    @typing.overload
    def set(self, key: index_entry_t, value: LinearCameraCal) -> None: ...
    @typing.overload
    def set(self, key: Key, value: PolynomialCameraCal) -> bool: ...
    @typing.overload
    def set(self, key: index_entry_t, value: PolynomialCameraCal) -> None: ...
    @typing.overload
    def set(self, key: Key, value: SphericalCameraCal) -> bool: ...
    @typing.overload
    def set(self, key: index_entry_t, value: SphericalCameraCal) -> None: ...
    @typing.overload
    def set(self, key: Key, value: numpy.ndarray) -> bool: ...
    @typing.overload
    def set(self, key: index_entry_t, value: numpy.ndarray) -> None: ...
    @typing.overload
    def update(self, index: index_t, other: Values) -> None:
        """
        Efficiently update the keys given by this index from other into this. This purely copies slices of the data arrays, the index MUST be valid for both objects!

        Efficiently update the keys from a different structured Values, given by this index and other index. This purely copies slices of the data arrays. index_this MUST be valid for this object; index_other MUST be valid for other object.
        """
    @typing.overload
    def update(self, index_this: index_t, index_other: index_t, other: Values) -> None: ...
    def update_or_set(self, index: index_t, other: Values) -> None:
        """
        Update or add keys to this Values base on other Values of different structure.
        index MUST be valid for other.

        NOTE(alvin): it is less efficient than the Update methods below if index objects are created and cached. This method performs map lookup for each key of the index
        """
    pass

def default_optimizer_params() -> optimizer_params_t:
    """
    Sensible default parameters for Optimizer.
    """

def optimize(
    params: optimizer_params_t,
    factors: typing.List[Factor],
    values: Values,
    epsilon: float = 2.220446049250313e-15,
) -> OptimizationStats:
    """
    Simple wrapper to make optimization one function call.
    """

def set_log_level(arg0: str) -> None:
    pass
