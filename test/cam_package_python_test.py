# -----------------------------------------------------------------------------
# This file was autogenerated by symforce from template:
#     tests/cam_package_python_test.py.jinja
# Do NOT modify by hand.
# -----------------------------------------------------------------------------


# ----------------------------------------------------------------------------
# SymForce - Copyright 2022, Skydio, Inc.
# This source code is under the Apache 2.0 license found in the LICENSE file.
# ----------------------------------------------------------------------------

import typing as T
import unittest

import numpy as np

import sym


class CamPackageTest(unittest.TestCase):
    """
    Tests for Python runtime camera types. Mostly checking basic generation logic
    since the math is tested comprehensively in symbolic form.
    """

    _DISTORTION_COEFF_VALS = {
        "ATANCameraCal": {"omega": 0.5},
        "DoubleSphereCameraCal": {"xi": 5.1, "alpha": -6.2},
        "PolynomialCameraCal": {
            "critical_undistorted_radius": 1.0471975511965976,
            "distortion_coeffs": [0.035, -0.025, 0.007],
        },
        "SphericalCameraCal": {
            "critical_theta": 3.141592653589793,
            "distortion_coeffs": [0.035, -0.025, 0.007, -0.0015],
        },
    }

    @staticmethod
    def cam_cal_from_points(cam_cls, focal_length, principal_point):
        # type: (T.Type, T.Sequence[float], T.Sequence[float]) -> T.Any
        return cam_cls(
            focal_length=focal_length,
            principal_point=principal_point,
            **CamPackageTest._DISTORTION_COEFF_VALS.get(cam_cls.__name__, {})
        )

    def test_getters_LinearCameraCal(self):
        # type: () -> None
        focal_length = [1.0, 2.0]
        principal_point = [3.0, 4.0]
        cam_cal = self.cam_cal_from_points(
            sym.LinearCameraCal, focal_length=focal_length, principal_point=principal_point
        )

        np.testing.assert_array_equal(np.array([focal_length]).T, cam_cal.focal_length())
        np.testing.assert_array_equal(np.array([principal_point]).T, cam_cal.principal_point())

        with self.subTest("Getters are compatible with the constructor"):
            new_cam_cal = self.cam_cal_from_points(
                sym.LinearCameraCal,
                focal_length=cam_cal.focal_length(),
                principal_point=cam_cal.principal_point(),
            )
            self.assertEqual(cam_cal.data, new_cam_cal.data)
            for x in new_cam_cal.data:
                self.assertIsInstance(x, float)

    def test_storage_ops_LinearCameraCal(self):
        # type: () -> None
        cam_cal = self.cam_cal_from_points(
            sym.LinearCameraCal, focal_length=[1.0, 2.0], principal_point=[3.0, 4.0]
        )
        storage = cam_cal.to_storage()

        self.assertEqual(cam_cal.storage_dim(), 4)
        self.assertEqual(len(storage), 4)

        cam_cal_copy = sym.LinearCameraCal.from_storage(storage)

        self.assertEqual(cam_cal, cam_cal_copy)

        cam_cal_different = sym.LinearCameraCal.from_storage([x + 1 for x in storage])

        self.assertNotEqual(cam_cal, cam_cal_different)

    def test_lie_group_ops_LinearCameraCal(self):
        # type: () -> None

        # NOTE(brad): The magic numbers come from the jinja template, and are the outputs of
        # of the symbolic class's methods.
        cam_cal = sym.LinearCameraCal.from_storage([1.0, 2.0, 3.0, 4.0])

        tangent = cam_cal.to_tangent(epsilon=1e-08)

        # Test tangent_dim is correct
        self.assertEqual(cam_cal.tangent_dim(), 4)

        # Test to_tangent is correct
        np.testing.assert_allclose(tangent, np.array([[1.0, 2.0, 3.0, 4.0]]).T)

        # Test from_tangent is correct
        np.testing.assert_allclose(
            sym.LinearCameraCal.from_tangent(vec=tangent, epsilon=1e-08).to_storage(),
            [1.0, 2.0, 3.0, 4.0],
        )

        second_cam_cal = sym.LinearCameraCal.from_storage([3.3, 5.5, 2.4, 3.8])

        # Test retract is correct
        np.testing.assert_allclose(
            second_cam_cal.retract(vec=tangent, epsilon=1e-08).to_storage(), [4.3, 7.5, 5.4, 7.8]
        )

        # Test local_coordinates is correct
        np.testing.assert_allclose(
            second_cam_cal.local_coordinates(cam_cal, epsilon=1e-08),
            np.array([[-2.3, -3.5, 0.6000000000000001, 0.20000000000000018]]).T,
        )

    def test_pixel_from_camera_point_LinearCameraCal(self):
        # type: () -> None

        # NOTE(brad): The magic numbers come from the jinja template, and are the outputs
        # of the symbolic class's methods.

        cam_cal = sym.LinearCameraCal.from_storage([1.0, 2.0, 3.0, 4.0])
        point = np.array([0.6, 0.8, 0.2])

        pixel, is_valid = cam_cal.pixel_from_camera_point(point=point, epsilon=1e-08)

        np.testing.assert_allclose(pixel, np.array([[6.0, 12.0]]).T)
        self.assertEqual(is_valid, 1.0)

        (
            j_pixel,
            j_is_valid,
            pixel_D_cal,
            pixel_D_point,
        ) = cam_cal.pixel_from_camera_point_with_jacobians(point=point, epsilon=1e-08)

        np.testing.assert_allclose(j_pixel, np.array([[6.0, 12.0]]).T)
        self.assertEqual(j_is_valid, 1.0)
        self.assertEqual(pixel_D_cal.shape, (2, 4))
        self.assertEqual(pixel_D_point.shape, (2, 3))

    def test_camera_ray_from_pixel_LinearCameraCal(self):
        # type: () -> None

        # NOTE(brad): The magic numbers come from the jinja template, and are the outputs of
        # of the symbolic class's methods.

        cam_cal = sym.LinearCameraCal.from_storage([1.0, 2.0, 3.0, 4.0])
        pixel = np.array([0.6, 0.8])

        ray, is_valid = cam_cal.camera_ray_from_pixel(pixel=pixel, epsilon=1e-08)

        np.testing.assert_allclose(ray, np.array([[-2.4, -1.6, 1.0]]).T)
        self.assertEqual(is_valid, 1.0)

        (
            j_ray,
            j_is_valid,
            point_D_cal,
            point_D_pixel,
        ) = cam_cal.camera_ray_from_pixel_with_jacobians(pixel=pixel, epsilon=1e-08)

        np.testing.assert_allclose(j_ray, np.array([[-2.4, -1.6, 1.0]]).T)
        self.assertEqual(j_is_valid, 1.0)
        self.assertEqual(point_D_cal.shape, (3, 4))
        self.assertEqual(point_D_pixel.shape, (3, 2))

    def test_getters_ATANCameraCal(self):
        # type: () -> None
        focal_length = [1.0, 2.0]
        principal_point = [3.0, 4.0]
        cam_cal = self.cam_cal_from_points(
            sym.ATANCameraCal, focal_length=focal_length, principal_point=principal_point
        )

        np.testing.assert_array_equal(np.array([focal_length]).T, cam_cal.focal_length())
        np.testing.assert_array_equal(np.array([principal_point]).T, cam_cal.principal_point())

        with self.subTest("Getters are compatible with the constructor"):
            new_cam_cal = self.cam_cal_from_points(
                sym.ATANCameraCal,
                focal_length=cam_cal.focal_length(),
                principal_point=cam_cal.principal_point(),
            )
            self.assertEqual(cam_cal.data, new_cam_cal.data)
            for x in new_cam_cal.data:
                self.assertIsInstance(x, float)

    def test_storage_ops_ATANCameraCal(self):
        # type: () -> None
        cam_cal = self.cam_cal_from_points(
            sym.ATANCameraCal, focal_length=[1.0, 2.0], principal_point=[3.0, 4.0]
        )
        storage = cam_cal.to_storage()

        self.assertEqual(cam_cal.storage_dim(), 5)
        self.assertEqual(len(storage), 5)

        cam_cal_copy = sym.ATANCameraCal.from_storage(storage)

        self.assertEqual(cam_cal, cam_cal_copy)

        cam_cal_different = sym.ATANCameraCal.from_storage([x + 1 for x in storage])

        self.assertNotEqual(cam_cal, cam_cal_different)

    def test_lie_group_ops_ATANCameraCal(self):
        # type: () -> None

        # NOTE(brad): The magic numbers come from the jinja template, and are the outputs of
        # of the symbolic class's methods.
        cam_cal = sym.ATANCameraCal.from_storage([1.0, 2.0, 3.0, 4.0, 0.5])

        tangent = cam_cal.to_tangent(epsilon=1e-08)

        # Test tangent_dim is correct
        self.assertEqual(cam_cal.tangent_dim(), 5)

        # Test to_tangent is correct
        np.testing.assert_allclose(tangent, np.array([[1.0, 2.0, 3.0, 4.0, 0.5]]).T)

        # Test from_tangent is correct
        np.testing.assert_allclose(
            sym.ATANCameraCal.from_tangent(vec=tangent, epsilon=1e-08).to_storage(),
            [1.0, 2.0, 3.0, 4.0, 0.5],
        )

        second_cam_cal = sym.ATANCameraCal.from_storage([3.3, 5.5, 2.4, 3.8, 0.5])

        # Test retract is correct
        np.testing.assert_allclose(
            second_cam_cal.retract(vec=tangent, epsilon=1e-08).to_storage(),
            [4.3, 7.5, 5.4, 7.8, 1.0],
        )

        # Test local_coordinates is correct
        np.testing.assert_allclose(
            second_cam_cal.local_coordinates(cam_cal, epsilon=1e-08),
            np.array([[-2.3, -3.5, 0.6000000000000001, 0.20000000000000018, 0.0]]).T,
        )

    def test_pixel_from_camera_point_ATANCameraCal(self):
        # type: () -> None

        # NOTE(brad): The magic numbers come from the jinja template, and are the outputs
        # of the symbolic class's methods.

        cam_cal = sym.ATANCameraCal.from_storage([1.0, 2.0, 3.0, 4.0, 0.5])
        point = np.array([0.6, 0.8, 0.2])

        pixel, is_valid = cam_cal.pixel_from_camera_point(point=point, epsilon=1e-08)

        np.testing.assert_allclose(pixel, np.array([[4.43702966477849, 7.83207910607598]]).T)
        self.assertEqual(is_valid, 1.0)

        (
            j_pixel,
            j_is_valid,
            pixel_D_cal,
            pixel_D_point,
        ) = cam_cal.pixel_from_camera_point_with_jacobians(point=point, epsilon=1e-08)

        np.testing.assert_allclose(j_pixel, np.array([[4.43702966477849, 7.83207910607598]]).T)
        self.assertEqual(j_is_valid, 1.0)
        self.assertEqual(pixel_D_cal.shape, (2, 5))
        self.assertEqual(pixel_D_point.shape, (2, 3))

    def test_camera_ray_from_pixel_ATANCameraCal(self):
        # type: () -> None

        # NOTE(brad): The magic numbers come from the jinja template, and are the outputs of
        # of the symbolic class's methods.

        cam_cal = sym.ATANCameraCal.from_storage([1.0, 2.0, 3.0, 4.0, 0.5])
        pixel = np.array([0.6, 0.8])

        ray, is_valid = cam_cal.camera_ray_from_pixel(pixel=pixel, epsilon=1e-08)

        np.testing.assert_allclose(ray, np.array([[-12.60188996700083, -8.401259978000553, 1.0]]).T)
        self.assertEqual(is_valid, 1.0)

        (
            j_ray,
            j_is_valid,
            point_D_cal,
            point_D_pixel,
        ) = cam_cal.camera_ray_from_pixel_with_jacobians(pixel=pixel, epsilon=1e-08)

        np.testing.assert_allclose(
            j_ray, np.array([[-12.60188996700083, -8.401259978000553, 1.0]]).T
        )
        self.assertEqual(j_is_valid, 1.0)
        self.assertEqual(point_D_cal.shape, (3, 5))
        self.assertEqual(point_D_pixel.shape, (3, 2))

    def test_getters_DoubleSphereCameraCal(self):
        # type: () -> None
        focal_length = [1.0, 2.0]
        principal_point = [3.0, 4.0]
        cam_cal = self.cam_cal_from_points(
            sym.DoubleSphereCameraCal, focal_length=focal_length, principal_point=principal_point
        )

        np.testing.assert_array_equal(np.array([focal_length]).T, cam_cal.focal_length())
        np.testing.assert_array_equal(np.array([principal_point]).T, cam_cal.principal_point())

        with self.subTest("Getters are compatible with the constructor"):
            new_cam_cal = self.cam_cal_from_points(
                sym.DoubleSphereCameraCal,
                focal_length=cam_cal.focal_length(),
                principal_point=cam_cal.principal_point(),
            )
            self.assertEqual(cam_cal.data, new_cam_cal.data)
            for x in new_cam_cal.data:
                self.assertIsInstance(x, float)

    def test_storage_ops_DoubleSphereCameraCal(self):
        # type: () -> None
        cam_cal = self.cam_cal_from_points(
            sym.DoubleSphereCameraCal, focal_length=[1.0, 2.0], principal_point=[3.0, 4.0]
        )
        storage = cam_cal.to_storage()

        self.assertEqual(cam_cal.storage_dim(), 6)
        self.assertEqual(len(storage), 6)

        cam_cal_copy = sym.DoubleSphereCameraCal.from_storage(storage)

        self.assertEqual(cam_cal, cam_cal_copy)

        cam_cal_different = sym.DoubleSphereCameraCal.from_storage([x + 1 for x in storage])

        self.assertNotEqual(cam_cal, cam_cal_different)

    def test_lie_group_ops_DoubleSphereCameraCal(self):
        # type: () -> None

        # NOTE(brad): The magic numbers come from the jinja template, and are the outputs of
        # of the symbolic class's methods.
        cam_cal = sym.DoubleSphereCameraCal.from_storage([1.0, 2.0, 3.0, 4.0, 5.1, -6.2])

        tangent = cam_cal.to_tangent(epsilon=1e-08)

        # Test tangent_dim is correct
        self.assertEqual(cam_cal.tangent_dim(), 6)

        # Test to_tangent is correct
        np.testing.assert_allclose(tangent, np.array([[1.0, 2.0, 3.0, 4.0, 5.1, -6.2]]).T)

        # Test from_tangent is correct
        np.testing.assert_allclose(
            sym.DoubleSphereCameraCal.from_tangent(vec=tangent, epsilon=1e-08).to_storage(),
            [1.0, 2.0, 3.0, 4.0, 5.1, -6.2],
        )

        second_cam_cal = sym.DoubleSphereCameraCal.from_storage([3.3, 5.5, 2.4, 3.8, 5.1, -6.2])

        # Test retract is correct
        np.testing.assert_allclose(
            second_cam_cal.retract(vec=tangent, epsilon=1e-08).to_storage(),
            [4.3, 7.5, 5.4, 7.8, 10.2, -12.4],
        )

        # Test local_coordinates is correct
        np.testing.assert_allclose(
            second_cam_cal.local_coordinates(cam_cal, epsilon=1e-08),
            np.array([[-2.3, -3.5, 0.6000000000000001, 0.20000000000000018, 0.0, 0.0]]).T,
        )

    def test_pixel_from_camera_point_DoubleSphereCameraCal(self):
        # type: () -> None

        # NOTE(brad): The magic numbers come from the jinja template, and are the outputs
        # of the symbolic class's methods.

        cam_cal = sym.DoubleSphereCameraCal.from_storage([1.0, 2.0, 3.0, 4.0, 5.1, -6.2])
        point = np.array([0.6, 0.8, 0.2])

        pixel, is_valid = cam_cal.pixel_from_camera_point(point=point, epsilon=1e-08)

        np.testing.assert_allclose(pixel, np.array([[3.12417556254144, 4.33113483344385]]).T)
        self.assertEqual(is_valid, 1.0)

        (
            j_pixel,
            j_is_valid,
            pixel_D_cal,
            pixel_D_point,
        ) = cam_cal.pixel_from_camera_point_with_jacobians(point=point, epsilon=1e-08)

        np.testing.assert_allclose(j_pixel, np.array([[3.12417556254144, 4.33113483344385]]).T)
        self.assertEqual(j_is_valid, 1.0)
        self.assertEqual(pixel_D_cal.shape, (2, 6))
        self.assertEqual(pixel_D_point.shape, (2, 3))

    def test_camera_ray_from_pixel_DoubleSphereCameraCal(self):
        # type: () -> None

        # NOTE(brad): The magic numbers come from the jinja template, and are the outputs of
        # of the symbolic class's methods.

        cam_cal = sym.DoubleSphereCameraCal.from_storage([1.0, 2.0, 3.0, 4.0, 5.1, -6.2])
        pixel = np.array([0.6, 0.8])

        ray, is_valid = cam_cal.camera_ray_from_pixel(pixel=pixel, epsilon=1e-08)

        np.testing.assert_allclose(
            ray, np.array([[-1.7554218715299938, -1.1702812476866626, -1.117691027921969]]).T
        )
        self.assertEqual(is_valid, 0.0)

        (
            j_ray,
            j_is_valid,
            point_D_cal,
            point_D_pixel,
        ) = cam_cal.camera_ray_from_pixel_with_jacobians(pixel=pixel, epsilon=1e-08)

        np.testing.assert_allclose(
            j_ray, np.array([[-1.7554218715299938, -1.1702812476866626, -1.117691027921969]]).T
        )
        self.assertEqual(j_is_valid, 0.0)
        self.assertEqual(point_D_cal.shape, (3, 6))
        self.assertEqual(point_D_pixel.shape, (3, 2))

    def test_getters_EquirectangularCameraCal(self):
        # type: () -> None
        focal_length = [1.0, 2.0]
        principal_point = [3.0, 4.0]
        cam_cal = self.cam_cal_from_points(
            sym.EquirectangularCameraCal, focal_length=focal_length, principal_point=principal_point
        )

        np.testing.assert_array_equal(np.array([focal_length]).T, cam_cal.focal_length())
        np.testing.assert_array_equal(np.array([principal_point]).T, cam_cal.principal_point())

        with self.subTest("Getters are compatible with the constructor"):
            new_cam_cal = self.cam_cal_from_points(
                sym.EquirectangularCameraCal,
                focal_length=cam_cal.focal_length(),
                principal_point=cam_cal.principal_point(),
            )
            self.assertEqual(cam_cal.data, new_cam_cal.data)
            for x in new_cam_cal.data:
                self.assertIsInstance(x, float)

    def test_storage_ops_EquirectangularCameraCal(self):
        # type: () -> None
        cam_cal = self.cam_cal_from_points(
            sym.EquirectangularCameraCal, focal_length=[1.0, 2.0], principal_point=[3.0, 4.0]
        )
        storage = cam_cal.to_storage()

        self.assertEqual(cam_cal.storage_dim(), 4)
        self.assertEqual(len(storage), 4)

        cam_cal_copy = sym.EquirectangularCameraCal.from_storage(storage)

        self.assertEqual(cam_cal, cam_cal_copy)

        cam_cal_different = sym.EquirectangularCameraCal.from_storage([x + 1 for x in storage])

        self.assertNotEqual(cam_cal, cam_cal_different)

    def test_lie_group_ops_EquirectangularCameraCal(self):
        # type: () -> None

        # NOTE(brad): The magic numbers come from the jinja template, and are the outputs of
        # of the symbolic class's methods.
        cam_cal = sym.EquirectangularCameraCal.from_storage([1.0, 2.0, 3.0, 4.0])

        tangent = cam_cal.to_tangent(epsilon=1e-08)

        # Test tangent_dim is correct
        self.assertEqual(cam_cal.tangent_dim(), 4)

        # Test to_tangent is correct
        np.testing.assert_allclose(tangent, np.array([[1.0, 2.0, 3.0, 4.0]]).T)

        # Test from_tangent is correct
        np.testing.assert_allclose(
            sym.EquirectangularCameraCal.from_tangent(vec=tangent, epsilon=1e-08).to_storage(),
            [1.0, 2.0, 3.0, 4.0],
        )

        second_cam_cal = sym.EquirectangularCameraCal.from_storage([3.3, 5.5, 2.4, 3.8])

        # Test retract is correct
        np.testing.assert_allclose(
            second_cam_cal.retract(vec=tangent, epsilon=1e-08).to_storage(), [4.3, 7.5, 5.4, 7.8]
        )

        # Test local_coordinates is correct
        np.testing.assert_allclose(
            second_cam_cal.local_coordinates(cam_cal, epsilon=1e-08),
            np.array([[-2.3, -3.5, 0.6000000000000001, 0.20000000000000018]]).T,
        )

    def test_pixel_from_camera_point_EquirectangularCameraCal(self):
        # type: () -> None

        # NOTE(brad): The magic numbers come from the jinja template, and are the outputs
        # of the symbolic class's methods.

        cam_cal = sym.EquirectangularCameraCal.from_storage([1.0, 2.0, 3.0, 4.0])
        point = np.array([0.6, 0.8, 0.2])

        pixel, is_valid = cam_cal.pixel_from_camera_point(point=point, epsilon=1e-08)

        np.testing.assert_allclose(pixel, np.array([[4.24904574989825, 5.80366449289037]]).T)
        self.assertEqual(is_valid, 1.0)

        (
            j_pixel,
            j_is_valid,
            pixel_D_cal,
            pixel_D_point,
        ) = cam_cal.pixel_from_camera_point_with_jacobians(point=point, epsilon=1e-08)

        np.testing.assert_allclose(j_pixel, np.array([[4.24904574989825, 5.80366449289037]]).T)
        self.assertEqual(j_is_valid, 1.0)
        self.assertEqual(pixel_D_cal.shape, (2, 4))
        self.assertEqual(pixel_D_point.shape, (2, 3))

    def test_camera_ray_from_pixel_EquirectangularCameraCal(self):
        # type: () -> None

        # NOTE(brad): The magic numbers come from the jinja template, and are the outputs of
        # of the symbolic class's methods.

        cam_cal = sym.EquirectangularCameraCal.from_storage([1.0, 2.0, 3.0, 4.0])
        pixel = np.array([0.6, 0.8])

        ray, is_valid = cam_cal.camera_ray_from_pixel(pixel=pixel, epsilon=1e-08)

        np.testing.assert_allclose(
            ray, np.array([[0.019723202204202806, -0.9995736030415051, 0.021531544241776817]]).T
        )
        self.assertEqual(is_valid, 0.0)

        (
            j_ray,
            j_is_valid,
            point_D_cal,
            point_D_pixel,
        ) = cam_cal.camera_ray_from_pixel_with_jacobians(pixel=pixel, epsilon=1e-08)

        np.testing.assert_allclose(
            j_ray, np.array([[0.019723202204202806, -0.9995736030415051, 0.021531544241776817]]).T
        )
        self.assertEqual(j_is_valid, 0.0)
        self.assertEqual(point_D_cal.shape, (3, 4))
        self.assertEqual(point_D_pixel.shape, (3, 2))

    def test_getters_PolynomialCameraCal(self):
        # type: () -> None
        focal_length = [1.0, 2.0]
        principal_point = [3.0, 4.0]
        cam_cal = self.cam_cal_from_points(
            sym.PolynomialCameraCal, focal_length=focal_length, principal_point=principal_point
        )

        np.testing.assert_array_equal(np.array([focal_length]).T, cam_cal.focal_length())
        np.testing.assert_array_equal(np.array([principal_point]).T, cam_cal.principal_point())

        with self.subTest("Getters are compatible with the constructor"):
            new_cam_cal = self.cam_cal_from_points(
                sym.PolynomialCameraCal,
                focal_length=cam_cal.focal_length(),
                principal_point=cam_cal.principal_point(),
            )
            self.assertEqual(cam_cal.data, new_cam_cal.data)
            for x in new_cam_cal.data:
                self.assertIsInstance(x, float)

    def test_storage_ops_PolynomialCameraCal(self):
        # type: () -> None
        cam_cal = self.cam_cal_from_points(
            sym.PolynomialCameraCal, focal_length=[1.0, 2.0], principal_point=[3.0, 4.0]
        )
        storage = cam_cal.to_storage()

        self.assertEqual(cam_cal.storage_dim(), 8)
        self.assertEqual(len(storage), 8)

        cam_cal_copy = sym.PolynomialCameraCal.from_storage(storage)

        self.assertEqual(cam_cal, cam_cal_copy)

        cam_cal_different = sym.PolynomialCameraCal.from_storage([x + 1 for x in storage])

        self.assertNotEqual(cam_cal, cam_cal_different)

    def test_lie_group_ops_PolynomialCameraCal(self):
        # type: () -> None

        # NOTE(brad): The magic numbers come from the jinja template, and are the outputs of
        # of the symbolic class's methods.
        cam_cal = sym.PolynomialCameraCal.from_storage(
            [1.0, 2.0, 3.0, 4.0, 1.0471975511965976, 0.035, -0.025, 0.007]
        )

        tangent = cam_cal.to_tangent(epsilon=1e-08)

        # Test tangent_dim is correct
        self.assertEqual(cam_cal.tangent_dim(), 8)

        # Test to_tangent is correct
        np.testing.assert_allclose(
            tangent, np.array([[1.0, 2.0, 3.0, 4.0, 1.0471975511965976, 0.035, -0.025, 0.007]]).T
        )

        # Test from_tangent is correct
        np.testing.assert_allclose(
            sym.PolynomialCameraCal.from_tangent(vec=tangent, epsilon=1e-08).to_storage(),
            [1.0, 2.0, 3.0, 4.0, 1.0471975511965976, 0.035, -0.025, 0.007],
        )

        second_cam_cal = sym.PolynomialCameraCal.from_storage(
            [3.3, 5.5, 2.4, 3.8, 1.0471975511965976, 0.035, -0.025, 0.007]
        )

        # Test retract is correct
        np.testing.assert_allclose(
            second_cam_cal.retract(vec=tangent, epsilon=1e-08).to_storage(),
            [4.3, 7.5, 5.4, 7.8, 2.0943951023931953, 0.07, -0.05, 0.014],
        )

        # Test local_coordinates is correct
        np.testing.assert_allclose(
            second_cam_cal.local_coordinates(cam_cal, epsilon=1e-08),
            np.array([[-2.3, -3.5, 0.6000000000000001, 0.20000000000000018, 0.0, 0.0, 0.0, 0.0]]).T,
        )

    def test_pixel_from_camera_point_PolynomialCameraCal(self):
        # type: () -> None

        # NOTE(brad): The magic numbers come from the jinja template, and are the outputs
        # of the symbolic class's methods.

        cam_cal = sym.PolynomialCameraCal.from_storage(
            [1.0, 2.0, 3.0, 4.0, 1.0471975511965976, 0.035, -0.025, 0.007]
        )
        point = np.array([0.6, 0.8, 0.2])

        pixel, is_valid = cam_cal.pixel_from_camera_point(point=point, epsilon=1e-08)

        np.testing.assert_allclose(pixel, np.array([[289.8750003573, 769.0000009528001]]).T)
        self.assertEqual(is_valid, 0.0)

        (
            j_pixel,
            j_is_valid,
            pixel_D_cal,
            pixel_D_point,
        ) = cam_cal.pixel_from_camera_point_with_jacobians(point=point, epsilon=1e-08)

        np.testing.assert_allclose(j_pixel, np.array([[289.8750003573, 769.0000009528001]]).T)
        self.assertEqual(j_is_valid, 0.0)
        self.assertEqual(pixel_D_cal.shape, (2, 7))
        self.assertEqual(pixel_D_point.shape, (2, 3))

    def test_getters_SphericalCameraCal(self):
        # type: () -> None
        focal_length = [1.0, 2.0]
        principal_point = [3.0, 4.0]
        cam_cal = self.cam_cal_from_points(
            sym.SphericalCameraCal, focal_length=focal_length, principal_point=principal_point
        )

        np.testing.assert_array_equal(np.array([focal_length]).T, cam_cal.focal_length())
        np.testing.assert_array_equal(np.array([principal_point]).T, cam_cal.principal_point())

        with self.subTest("Getters are compatible with the constructor"):
            new_cam_cal = self.cam_cal_from_points(
                sym.SphericalCameraCal,
                focal_length=cam_cal.focal_length(),
                principal_point=cam_cal.principal_point(),
            )
            self.assertEqual(cam_cal.data, new_cam_cal.data)
            for x in new_cam_cal.data:
                self.assertIsInstance(x, float)

    def test_storage_ops_SphericalCameraCal(self):
        # type: () -> None
        cam_cal = self.cam_cal_from_points(
            sym.SphericalCameraCal, focal_length=[1.0, 2.0], principal_point=[3.0, 4.0]
        )
        storage = cam_cal.to_storage()

        self.assertEqual(cam_cal.storage_dim(), 9)
        self.assertEqual(len(storage), 9)

        cam_cal_copy = sym.SphericalCameraCal.from_storage(storage)

        self.assertEqual(cam_cal, cam_cal_copy)

        cam_cal_different = sym.SphericalCameraCal.from_storage([x + 1 for x in storage])

        self.assertNotEqual(cam_cal, cam_cal_different)

    def test_lie_group_ops_SphericalCameraCal(self):
        # type: () -> None

        # NOTE(brad): The magic numbers come from the jinja template, and are the outputs of
        # of the symbolic class's methods.
        cam_cal = sym.SphericalCameraCal.from_storage(
            [1.0, 2.0, 3.0, 4.0, 3.141592653589793, 0.035, -0.025, 0.007, -0.0015]
        )

        tangent = cam_cal.to_tangent(epsilon=1e-08)

        # Test tangent_dim is correct
        self.assertEqual(cam_cal.tangent_dim(), 9)

        # Test to_tangent is correct
        np.testing.assert_allclose(
            tangent,
            np.array([[1.0, 2.0, 3.0, 4.0, 3.141592653589793, 0.035, -0.025, 0.007, -0.0015]]).T,
        )

        # Test from_tangent is correct
        np.testing.assert_allclose(
            sym.SphericalCameraCal.from_tangent(vec=tangent, epsilon=1e-08).to_storage(),
            [1.0, 2.0, 3.0, 4.0, 3.141592653589793, 0.035, -0.025, 0.007, -0.0015],
        )

        second_cam_cal = sym.SphericalCameraCal.from_storage(
            [3.3, 5.5, 2.4, 3.8, 3.141592653589793, 0.035, -0.025, 0.007, -0.0015]
        )

        # Test retract is correct
        np.testing.assert_allclose(
            second_cam_cal.retract(vec=tangent, epsilon=1e-08).to_storage(),
            [4.3, 7.5, 5.4, 7.8, 6.283185307179586, 0.07, -0.05, 0.014, -0.003],
        )

        # Test local_coordinates is correct
        np.testing.assert_allclose(
            second_cam_cal.local_coordinates(cam_cal, epsilon=1e-08),
            np.array(
                [[-2.3, -3.5, 0.6000000000000001, 0.20000000000000018, 0.0, 0.0, 0.0, 0.0, 0.0]]
            ).T,
        )

    def test_pixel_from_camera_point_SphericalCameraCal(self):
        # type: () -> None

        # NOTE(brad): The magic numbers come from the jinja template, and are the outputs
        # of the symbolic class's methods.

        cam_cal = sym.SphericalCameraCal.from_storage(
            [1.0, 2.0, 3.0, 4.0, 3.141592653589793, 0.035, -0.025, 0.007, -0.0015]
        )
        point = np.array([0.6, 0.8, 0.2])

        pixel, is_valid = cam_cal.pixel_from_camera_point(point=point, epsilon=1e-08)

        np.testing.assert_allclose(pixel, np.array([[3.82821053086175, 6.20856141563133]]).T)
        self.assertEqual(is_valid, 1.0)

        (
            j_pixel,
            j_is_valid,
            pixel_D_cal,
            pixel_D_point,
        ) = cam_cal.pixel_from_camera_point_with_jacobians(point=point, epsilon=1e-08)

        np.testing.assert_allclose(j_pixel, np.array([[3.82821053086175, 6.20856141563133]]).T)
        self.assertEqual(j_is_valid, 1.0)
        self.assertEqual(pixel_D_cal.shape, (2, 8))
        self.assertEqual(pixel_D_point.shape, (2, 3))


if __name__ == "__main__":
    unittest.main()
