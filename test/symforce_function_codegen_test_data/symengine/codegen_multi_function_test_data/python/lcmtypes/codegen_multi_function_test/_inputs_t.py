# This file automatically generated by skymarshal
# DO NOT MODIFY BY HAND
# fmt: off
# isort: off
# mypy: disallow-untyped-defs

import copy
import typing as T  # pylint: disable=unused-import

from io import BytesIO
import struct
from lcmtypes.codegen_multi_function_test._inputs_constants_t import inputs_constants_t
from lcmtypes.codegen_multi_function_test._inputs_states_t import inputs_states_t
from lcmtypes.codegen_multi_function_test._values_vec_t import values_vec_t
from lcmtypes.eigen_lcm._Vector4d import Vector4d
from lcmtypes.eigen_lcm._VectorXd import VectorXd

class inputs_t(object):
    __slots__ = ["x", "y", "rot", "rot_vec", "scalar_vec", "list_of_lists", "values_vec", "values_vec_2D", "constants", "big_matrix", "states"]  # type: T.List[str]

    def __init__(
        self,
        x=0.0,  # type: float
        y=0.0,  # type: float
        rot=None,  # type: Vector4d
        rot_vec=None,  # type: T.List[Vector4d]
        scalar_vec=None,  # type: T.List[float]
        list_of_lists=None,  # type: T.List[T.List[Vector4d]]
        values_vec=None,  # type: T.List[values_vec_t]
        values_vec_2D=None,  # type: T.List[T.List[values_vec_t]]
        constants=None,  # type: inputs_constants_t
        big_matrix=None,  # type: VectorXd
        states=None,  # type: inputs_states_t
        _skip_initialize=False,  # type: bool
    ):
        # type: (...) -> None
        """ If _skip_initialize is True, all other constructor arguments are ignored """
        if _skip_initialize:
            return
        self.x = x
        self.y = y
        self.rot = Vector4d._default() if rot is None else rot  # type: Vector4d
        self.rot_vec = [ Vector4d._default() for dim0 in range(3) ] if rot_vec is None else rot_vec  # type: T.List[Vector4d]
        self.scalar_vec = [ 0.0 for dim0 in range(3) ] if scalar_vec is None else scalar_vec  # type: T.List[float]
        self.list_of_lists = [ [ Vector4d._default() for dim1 in range(3) ] for dim0 in range(3) ] if list_of_lists is None else list_of_lists  # type: T.List[T.List[Vector4d]]
        self.values_vec = [ values_vec_t._default() for dim0 in range(3) ] if values_vec is None else values_vec  # type: T.List[values_vec_t]
        self.values_vec_2D = [ [ values_vec_t._default() for dim1 in range(1) ] for dim0 in range(2) ] if values_vec_2D is None else values_vec_2D  # type: T.List[T.List[values_vec_t]]
        self.constants = inputs_constants_t._default() if constants is None else constants  # type: inputs_constants_t
        self.big_matrix = VectorXd._default() if big_matrix is None else big_matrix  # type: VectorXd
        self.states = inputs_states_t._default() if states is None else states  # type: inputs_states_t

    @staticmethod
    def from_all_fields(
        x,  # type: float
        y,  # type: float
        rot,  # type: Vector4d
        rot_vec,  # type: T.List[Vector4d]
        scalar_vec,  # type: T.List[float]
        list_of_lists,  # type: T.List[T.List[Vector4d]]
        values_vec,  # type: T.List[values_vec_t]
        values_vec_2D,  # type: T.List[T.List[values_vec_t]]
        constants,  # type: inputs_constants_t
        big_matrix,  # type: VectorXd
        states,  # type: inputs_states_t
    ):
        # type: (...) -> inputs_t
        return inputs_t(
            x=x,
            y=y,
            rot=rot,
            rot_vec=rot_vec,
            scalar_vec=scalar_vec,
            list_of_lists=list_of_lists,
            values_vec=values_vec,
            values_vec_2D=values_vec_2D,
            constants=constants,
            big_matrix=big_matrix,
            states=states,
        )

    @staticmethod
    def _skytype_meta():
        # type: () -> T.Dict[str, str]
        return dict(
            type="struct",
            package="codegen_multi_function_test",
            name="inputs_t",
        )

    @classmethod
    def _default(cls):
        # type: () -> inputs_t
        return cls()

    def __repr__(self):
        # type: () -> str
        return "inputs_t({})".format(
            ", ".join("{}={}".format(name, repr(getattr(self, name))) for name in self.__slots__))

    def __eq__(self, other):
        # type: (object) -> bool
        if not isinstance(other, inputs_t):
            return NotImplemented
        return (
            (self.x==other.x) and
            (self.y==other.y) and
            (self.rot==other.rot) and
            (self.rot_vec==other.rot_vec) and
            (self.scalar_vec==other.scalar_vec) and
            (self.list_of_lists==other.list_of_lists) and
            (self.values_vec==other.values_vec) and
            (self.values_vec_2D==other.values_vec_2D) and
            (self.constants==other.constants) and
            (self.big_matrix==other.big_matrix) and
            (self.states==other.states)
        )
    # Disallow hashing for python struct lcmtypes.
    __hash__ = None  # type: ignore

    def encode(self):
        # type: () -> bytes
        buf = BytesIO()
        buf.write(inputs_t._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        # type: (T.BinaryIO) -> None
        buf.write(inputs_t._CACHED_STRUCT_0.pack(self.x, self.y))
        if hasattr(self.rot, '_get_packed_fingerprint'):
            assert self.rot._get_packed_fingerprint() == Vector4d._get_packed_fingerprint()
        else:
            assert self.rot._get_hash_recursive([]) == Vector4d._get_hash_recursive([])
        self.rot._encode_one(buf)
        for i0 in range(3):
            if hasattr(self.rot_vec[i0], '_get_packed_fingerprint'):
                assert self.rot_vec[i0]._get_packed_fingerprint() == Vector4d._get_packed_fingerprint()
            else:
                assert self.rot_vec[i0]._get_hash_recursive([]) == Vector4d._get_hash_recursive([])
            self.rot_vec[i0]._encode_one(buf)
        buf.write(inputs_t._CACHED_STRUCT_1.pack(*self.scalar_vec[:3]))
        for i0 in range(3):
            for i1 in range(3):
                if hasattr(self.list_of_lists[i0][i1], '_get_packed_fingerprint'):
                    assert self.list_of_lists[i0][i1]._get_packed_fingerprint() == Vector4d._get_packed_fingerprint()
                else:
                    assert self.list_of_lists[i0][i1]._get_hash_recursive([]) == Vector4d._get_hash_recursive([])
                self.list_of_lists[i0][i1]._encode_one(buf)
        for i0 in range(3):
            if hasattr(self.values_vec[i0], '_get_packed_fingerprint'):
                assert self.values_vec[i0]._get_packed_fingerprint() == values_vec_t._get_packed_fingerprint()
            else:
                assert self.values_vec[i0]._get_hash_recursive([]) == values_vec_t._get_hash_recursive([])
            self.values_vec[i0]._encode_one(buf)
        for i0 in range(2):
            for i1 in range(1):
                if hasattr(self.values_vec_2D[i0][i1], '_get_packed_fingerprint'):
                    assert self.values_vec_2D[i0][i1]._get_packed_fingerprint() == values_vec_t._get_packed_fingerprint()
                else:
                    assert self.values_vec_2D[i0][i1]._get_hash_recursive([]) == values_vec_t._get_hash_recursive([])
                self.values_vec_2D[i0][i1]._encode_one(buf)
        if hasattr(self.constants, '_get_packed_fingerprint'):
            assert self.constants._get_packed_fingerprint() == inputs_constants_t._get_packed_fingerprint()
        else:
            assert self.constants._get_hash_recursive([]) == inputs_constants_t._get_hash_recursive([])
        self.constants._encode_one(buf)
        if hasattr(self.big_matrix, '_get_packed_fingerprint'):
            assert self.big_matrix._get_packed_fingerprint() == VectorXd._get_packed_fingerprint()
        else:
            assert self.big_matrix._get_hash_recursive([]) == VectorXd._get_hash_recursive([])
        self.big_matrix._encode_one(buf)
        if hasattr(self.states, '_get_packed_fingerprint'):
            assert self.states._get_packed_fingerprint() == inputs_states_t._get_packed_fingerprint()
        else:
            assert self.states._get_hash_recursive([]) == inputs_states_t._get_hash_recursive([])
        self.states._encode_one(buf)

    @staticmethod
    def decode(data):
        # type: (T.Union[bytes, T.BinaryIO]) -> inputs_t
        # NOTE(eric): This function can technically accept either a BinaryIO or
        # anything that supports the C++ Buffer Protocol,
        # which is unspecifiable in type hints.

        if hasattr(data, "read"):
            # NOTE(eric): mypy isn't able to figure out the hasattr check
            buf = T.cast(T.BinaryIO, data)
        else:
            buf = BytesIO(T.cast(bytes, data))

        if buf.read(8) != inputs_t._get_packed_fingerprint():
            raise ValueError("Decode error")
        return inputs_t._decode_one(buf)

    @staticmethod
    def _decode_one(buf):
        # type: (T.BinaryIO) -> inputs_t
        self = inputs_t(_skip_initialize=True)
        self.x, self.y = inputs_t._CACHED_STRUCT_0.unpack(buf.read(16))
        self.rot = Vector4d._decode_one(buf)
        self.rot_vec = []
        for i0 in range(3):
            self.rot_vec.append(Vector4d._decode_one(buf))
        self.scalar_vec = list(inputs_t._CACHED_STRUCT_1.unpack(buf.read(24)))
        self.list_of_lists = []
        for i0 in range(3):
            self.list_of_lists.append ([])
            for i1 in range(3):
                self.list_of_lists[i0].append(Vector4d._decode_one(buf))
        self.values_vec = []
        for i0 in range(3):
            self.values_vec.append(values_vec_t._decode_one(buf))
        self.values_vec_2D = []
        for i0 in range(2):
            self.values_vec_2D.append ([])
            for i1 in range(1):
                self.values_vec_2D[i0].append(values_vec_t._decode_one(buf))
        self.constants = inputs_constants_t._decode_one(buf)
        self.big_matrix = VectorXd._decode_one(buf)
        self.states = inputs_states_t._decode_one(buf)
        return self

    @staticmethod
    def _get_hash_recursive(parents):
        # type: (T.List[T.Type]) -> int
        if inputs_t in parents: return 0
        newparents = parents + [inputs_t]
        tmphash = (0xadf229d823991ada+ Vector4d._get_hash_recursive(newparents)+ Vector4d._get_hash_recursive(newparents)+ Vector4d._get_hash_recursive(newparents)+ values_vec_t._get_hash_recursive(newparents)+ values_vec_t._get_hash_recursive(newparents)+ inputs_constants_t._get_hash_recursive(newparents)+ VectorXd._get_hash_recursive(newparents)+ inputs_states_t._get_hash_recursive(newparents)) & 0xffffffffffffffff
        tmphash = (((tmphash<<1)&0xffffffffffffffff)  + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash

    _packed_fingerprint = None  # type: T.Optional[bytes]

    @staticmethod
    def _get_packed_fingerprint():
        # type: () -> bytes
        if inputs_t._packed_fingerprint is None:
            inputs_t._packed_fingerprint = struct.pack(">Q", inputs_t._get_hash_recursive([]))
        return inputs_t._packed_fingerprint

    def deepcopy(self, **kwargs):
        # type: (**T.Any) -> inputs_t
        """
        Deep copy of this LCM type

        Returns a copy w/ members specified by kwargs replaced with new values specified by kwargs.
        """
        result = copy.deepcopy(self)
        for key in kwargs:
            if not hasattr(result, key):
                raise KeyError("Type inputs_t does not have attribute: " + str(key))
            setattr(result, key, kwargs[key])
        return result

    _CACHED_STRUCT_0 = struct.Struct(">dd")
    _CACHED_STRUCT_1 = struct.Struct(">3d")
