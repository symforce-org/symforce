// -----------------------------------------------------------------------------
// This file was autogenerated by symforce from template:
//     function/FUNCTION.cu.jinja
// Do NOT modify by hand.
// -----------------------------------------------------------------------------

namespace sym {

__host__ __device__ void CudaFuncVectorsReturnNone(
    const float a, const float* const __restrict__ b, const float* const __restrict__ c,
    const float* const __restrict__ d, const float* const __restrict__ e,
    const float* const __restrict__ f, const float* const __restrict__ g,
    float* const __restrict__ a_out, float1* const __restrict__ b_out,
    float3* const __restrict__ c_out, float4* const __restrict__ d_out,
    float* const __restrict__ e_out, float* const __restrict__ f_out) {
  // Total ops: 36

  // Intermediate terms (0)

  // Output terms (6)
  if (a_out != nullptr) {
    *a_out = a;
  }

  if (b_out != nullptr) {
    float1& _b_out = *b_out;

    _b_out.x = b[0];
  }

  if (c_out != nullptr) {
    float3& _c_out = *c_out;

    _c_out.x = c[0];
    _c_out.y = c[1];
    _c_out.z = c[2];
  }

  if (d_out != nullptr) {
    float4& _d_out = *d_out;

    _d_out.x = d[0];
    _d_out.z = d[2];
    _d_out.y = d[1];
    _d_out.w = d[3];
  }

  if (e_out != nullptr) {
    e_out[0] = e[0];
    e_out[1] = e[1];
    e_out[2] = e[2];
    e_out[3] = e[3];
    e_out[4] = e[4];
  }

  if (f_out != nullptr) {
    f_out[0] = f[0] + g[static_cast<size_t>(0)];
    f_out[6] = f[6] + g[static_cast<size_t>(0)];
    f_out[12] = f[12] + g[static_cast<size_t>(0)];
    f_out[18] = f[18] + g[static_cast<size_t>(0)];
    f_out[24] = f[24] + g[static_cast<size_t>(0)];
    f_out[30] = f[30] + g[static_cast<size_t>(0)];
    f_out[1] = f[1] + g[static_cast<size_t>(0)];
    f_out[7] = f[7] + g[static_cast<size_t>(0)];
    f_out[13] = f[13] + g[static_cast<size_t>(0)];
    f_out[19] = f[19] + g[static_cast<size_t>(0)];
    f_out[25] = f[25] + g[static_cast<size_t>(0)];
    f_out[31] = f[31] + g[static_cast<size_t>(0)];
    f_out[2] = f[2] + g[static_cast<size_t>(0)];
    f_out[8] = f[8] + g[static_cast<size_t>(0)];
    f_out[14] = f[14] + g[static_cast<size_t>(0)];
    f_out[20] = f[20] + g[static_cast<size_t>(0)];
    f_out[26] = f[26] + g[static_cast<size_t>(0)];
    f_out[32] = f[32] + g[static_cast<size_t>(0)];
    f_out[3] = f[3] + g[static_cast<size_t>(0)];
    f_out[9] = f[9] + g[static_cast<size_t>(0)];
    f_out[15] = f[15] + g[static_cast<size_t>(0)];
    f_out[21] = f[21] + g[static_cast<size_t>(0)];
    f_out[27] = f[27] + g[static_cast<size_t>(0)];
    f_out[33] = f[33] + g[static_cast<size_t>(0)];
    f_out[4] = f[4] + g[static_cast<size_t>(0)];
    f_out[10] = f[10] + g[static_cast<size_t>(0)];
    f_out[16] = f[16] + g[static_cast<size_t>(0)];
    f_out[22] = f[22] + g[static_cast<size_t>(0)];
    f_out[28] = f[28] + g[static_cast<size_t>(0)];
    f_out[34] = f[34] + g[static_cast<size_t>(0)];
    f_out[5] = f[5] + g[static_cast<size_t>(0)];
    f_out[11] = f[11] + g[static_cast<size_t>(0)];
    f_out[17] = f[17] + g[static_cast<size_t>(0)];
    f_out[23] = f[23] + g[static_cast<size_t>(0)];
    f_out[29] = f[29] + g[static_cast<size_t>(0)];
    f_out[35] = f[35] + g[static_cast<size_t>(0)];
  }
}

}  // namespace sym
