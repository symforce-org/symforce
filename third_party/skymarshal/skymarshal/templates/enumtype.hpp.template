/** THIS IS AN AUTOMATICALLY GENERATED FILE.  DO NOT MODIFY
 * BY HAND!!
 *
 * Generated by lcm-gen
 **/

#include <lcm/lcm_coretypes.h>

#ifndef __{{enumtype.underscored}}_hpp__
#define __{{enumtype.underscored}}_hpp__

#include <array>
#include <ostream>

namespace {{enumtype.namespace}}
{
{{enumtype.comment}}
class {{enumtype.name}}
{
    public:
        enum option_t : {{enumtype.storage_type}} {
{% for case in enumtype.cases %}
            {{case.name}} = {{case.int_value}},
{% endfor %}
        };

    public:
        option_t value;

    public:
        {{enumtype.name}}() = default;

        /**
         * Member constructor
         */
        inline constexpr {{enumtype.name}}(const option_t& value_arg);

        /**
         * Conversion to {{enumtype.storage_type}} value.
         */
        inline {{enumtype.storage_type}} int_value() const;

        /**
         * Static constructor from {{enumtype.storage_type}} value.  Does not validate the value.
         */
        static inline {{enumtype.name}} from_int({{enumtype.storage_type}} int_value);

        /**
         * Get all values of the enum as a std::array.
         */
        static inline constexpr std::array<option_t, {{enumtype.num_cases}}> values();

        /**
         * Get const-char pointer of the enum string.
         */
        inline const char* string_value() const;

        /**
         * Encode a message into binary form.
         *
         * @param buf The output buffer.
         * @param offset Encoding starts at thie byte offset into @p buf.
         * @param maxlen Maximum number of bytes to write.  This should generally be
         *  equal to getEncodedSize().
         * @return The number of bytes encoded, or <0 on error.
         */
        inline {{ size_t }} encode(void *buf, {{ size_t }} offset, {{ size_t }} maxlen) const;

        /**
         * Check how many bytes are required to encode this message.
         */
        inline {{ size_t }} getEncodedSize() const;

        /**
         * Decode a message from binary form into this instance.
         *
         * @param buf The buffer containing the encoded message.
         * @param offset The byte offset into @p buf where the encoded message starts.
         * @param maxlen The maximum number of bytes to read while decoding.
         * @return The number of bytes decoded, or <0 if an error occured.
         */
        inline {{ size_t }} decode(const void *buf, {{ size_t }} offset, {{ size_t }} maxlen);

        /**
         * Retrieve the 64-bit fingerprint identifying the structure of the message.
         * Note that the fingerprint is the same for all instances of the same
         * message type, and is a fingerprint on the message type definition, not on
         * the message contents.
         */
        constexpr static int64_t getHash();

        /**
         * Returns "{{enumtype.name}}"
         */
        inline static const char* getTypeName();

        /**
         * Returns "{{enumtype.namespace}}"
         */
        inline static const char * getPackageName();

        // LCM support functions. Users should not call these
        inline {{ size_t }} _encodeNoHash(void *buf, {{ size_t }} offset, {{ size_t }} maxlen) const;
        inline {{ size_t }} _getEncodedSizeNoHash() const;
        inline {{ size_t }} _decodeNoHash(const void *buf, {{ size_t }} offset, {{ size_t }} maxlen);
        constexpr static uint64_t _computeHash(const __lcm_hash_ptr *p);
};

constexpr {{enumtype.name}}::{{enumtype.name}}(
    const {{enumtype.name}}::option_t& value_arg
) : value(value_arg) {}

{{enumtype.storage_type}} {{enumtype.name}}::int_value() const {
    return static_cast<{{enumtype.storage_type}}>(value);
}

{{enumtype.name}} {{enumtype.name}}::from_int({{enumtype.storage_type}} int_value) {
    return {{enumtype.name}}(static_cast<option_t>(int_value));
}

{{ size_t }} {{enumtype.name}}::encode(void *buf, {{ size_t }} offset, {{ size_t }} maxlen) const
{
    {{ size_t }} pos = 0, tlen;
    int64_t hash = (int64_t)getHash();

    tlen = __int64_t_encode_array(buf, offset + pos, maxlen - pos, &hash, 1);
    if(tlen < 0) return tlen; else pos += tlen;

    tlen = this->_encodeNoHash(buf, offset + pos, maxlen - pos);
    if (tlen < 0) return tlen; else pos += tlen;

    return pos;
}

{{ size_t }} {{enumtype.name}}::decode(const void *buf, {{ size_t }} offset, {{ size_t }} maxlen)
{
    {{ size_t }} pos = 0, thislen;

    int64_t msg_hash;
    thislen = __int64_t_decode_array(buf, offset + pos, maxlen - pos, &msg_hash, 1);
    if (thislen < 0) return thislen; else pos += thislen;
    if (msg_hash != getHash()) return -1;

    thislen = this->_decodeNoHash(buf, offset + pos, maxlen - pos);
    if (thislen < 0) return thislen; else pos += thislen;

    return pos;
}

{{ size_t }} {{enumtype.name}}::getEncodedSize() const
{
    return 8 + _getEncodedSizeNoHash();
}

constexpr int64_t {{enumtype.name}}::getHash()
{
    return _computeHash(NULL);
}

const char* {{enumtype.name}}::getTypeName()
{
    return "{{enumtype.name}}";
}

const char * {{enumtype.name}}::getPackageName()
{
    return "{{enumtype.namespace}}";
}

{{ size_t }} {{enumtype.name}}::_encodeNoHash(void *buf, {{ size_t }} offset, {{ size_t }} maxlen) const
{
    {{ size_t }} pos = 0, tlen;

    tlen = __{{enumtype.storage_type}}_encode_array(buf, offset + pos, maxlen - pos, reinterpret_cast<const {{enumtype.storage_type}}*>(&this->value), 1);
    if(tlen < 0) return tlen; else pos += tlen;

    return pos;
}

{{ size_t }} {{enumtype.name}}::_decodeNoHash(const void *buf, {{ size_t }} offset, {{ size_t }} maxlen)
{
    {{ size_t }} pos = 0, tlen;

    tlen = __{{enumtype.storage_type}}_decode_array(buf, offset + pos, maxlen - pos, reinterpret_cast<{{enumtype.storage_type}}*>(&this->value), 1);
    if(tlen < 0) return tlen; else pos += tlen;

    return pos;
}

{{ size_t }} {{enumtype.name}}::_getEncodedSizeNoHash() const
{
    {{ size_t }} enc_size = 0;
    enc_size += __{{enumtype.storage_type}}_encoded_array_size(NULL, 1);
    return enc_size;
}

constexpr uint64_t {{enumtype.name}}::_computeHash(const __lcm_hash_ptr *)
{
    uint64_t hash = {{enumtype.hash}}L;
    return (hash<<1) + ((hash>>63)&1);
}

inline bool operator==(const {{enumtype.name}}& a, const {{enumtype.name}}& b)
{
    return a.value == b.value;
}

inline bool operator!=(const {{enumtype.name}}& a, const {{enumtype.name}}& b)
{
    return !(a == b);
}

inline bool operator<(const {{enumtype.name}}& a, const {{enumtype.name}}& b)
{
    return a.value < b.value;
}

inline constexpr std::array<{{enumtype.name}}::option_t, {{enumtype.num_cases}}> {{enumtype.name}}::values()
{
    return {{ '{{' }}
{% for case in enumtype.cases %}
        {{case.name}},
{% endfor %}
    {{ '}}' }};
}

inline const char* {{enumtype.name}}::string_value() const
{
    switch (value) {
{% for case in enumtype.cases %}
        case {{enumtype.name}}::{{case.name}}:
            return "{{case.name}}";
{% endfor %}
    }
    return "{{enumtype.name}}::<UNKNOWN VALUE>";
}

inline std::ostream& operator <<(std::ostream& s, const {{enumtype.name}}::option_t& option)
{
    switch (option) {
{% for case in enumtype.cases %}
        case {{enumtype.name}}::{{case.name}}:
            return s << "{{case.name}}";
{% endfor %}
    }
    return s << "{{enumtype.name}}::" << static_cast<{{enumtype.string_cast_type}}>(option);
}

inline std::ostream& operator <<(std::ostream& s, const {{enumtype.name}}& object)
{
    return s << object.value;
}

}  // namespace  {{enumtype.namespace}}

// Allow enum as an unordered_map key
// http://stackoverflow.com/a/18838036
namespace std {
template <>
struct hash<::{{enumtype.namespace}}::{{enumtype.name}}> {
    typedef ::{{enumtype.namespace}}::{{enumtype.name}} argument_type;
    typedef std::underlying_type<argument_type::option_t>::type underlying_type;
    std::size_t operator()(const argument_type& arg) const {
        std::hash<underlying_type> hasher;
        return hasher(static_cast<underlying_type>(arg.value));
    }
};
} // namespace std

#endif
